<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>svFSIplus: Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">svFSIplus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md7">Introduction</a></li>
<li class="level1"><a href="#autotoc_md8">Code Organization</a></li>
<li class="level1"><a href="#autotoc_md9">Translating Fortran into C++</a><ul><li class="level2"><a href="#autotoc_md10">Variable Names</a></li>
<li class="level2"><a href="#autotoc_md11">Fortran Modules</a></li>
<li class="level2"><a href="#autotoc_md12">Fortran Dynamic Arrays</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md13">Simulation Class</a></li>
<li class="level1"><a href="#autotoc_md14">Array and Vector Class Templates</a><ul><li class="level2"><a href="#autotoc_md15">Allocating and Freeing Memory</a></li>
<li class="level2"><a href="#autotoc_md16">Indexing and Memory Layout</a></li>
<li class="level2"><a href="#autotoc_md17">Operators</a></li>
<li class="level2"><a href="#autotoc_md18">Getting an Array Column</a></li>
<li class="level2"><a href="#autotoc_md19">Getting an Array3 Slice</a></li>
<li class="level2"><a href="#autotoc_md20">Fortran 0-size Arrays</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md21">Solver Parameter Input XML File</a><ul><li class="level2"><a href="#autotoc_md22">Parameters class</a></li>
<li class="level2"><a href="#autotoc_md23">Accessing Parameters</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md24">Performance and Accuracy</a></li>
<li class="level1"><a href="#autotoc_md25">Potential Problems</a><ul><li class="level2"><a href="#autotoc_md26">Indexing Mistakes</a></li>
<li class="level2"><a href="#autotoc_md27">Fortran 0-size Arrays</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md28">Implementation Details</a><ul><li class="level2"><a href="#autotoc_md29">References vs. Pointers</a></li>
<li class="level2"><a href="#autotoc_md30">Constants</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md31">Coding Standards</a><ul><li class="level2"><a href="#autotoc_md32">Indentation</a></li>
<li class="level2"><a href="#autotoc_md33">White Space</a></li>
<li class="level2"><a href="#autotoc_md34">Namespaces</a></li>
<li class="level2"><a href="#autotoc_md35">Naming Conventions</a></li>
<li class="level2"><a href="#autotoc_md36">Styles</a></li>
<li class="level2"><a href="#autotoc_md37">File Names</a></li>
<li class="level2"><a href="#autotoc_md38">Type Names</a></li>
<li class="level2"><a href="#autotoc_md39">Variable and Functions Names</a></li>
<li class="level2"><a href="#autotoc_md40">Comments</a></li>
<li class="level2"><a href="#autotoc_md41">File Comments</a></li>
<li class="level2"><a href="#autotoc_md42">Class Comments</a></li>
<li class="level2"><a href="#autotoc_md43">Function Comments</a></li>
<li class="level2"><a href="#autotoc_md44">Variables</a></li>
<li class="level2"><a href="#autotoc_md45">General Programming</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md46">Coding Guidelines</a><ul><li class="level2"><a href="#autotoc_md47">Enums</a></li>
<li class="level2"><a href="#autotoc_md48">Type Conversions</a></li>
<li class="level2"><a href="#autotoc_md49">Function Parameters</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This document describes some of the implementation details of svFSIplus C++ code.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Introduction</h1>
<p>svFSIplus is essentially a direct line-by-line translation of the <a href="https://github.com/SimVascular/svFSI">svFSI</a> Fortran code into C++. This provides a simple mapping between the code of the original Fortran and C++ versions and aided in debugging the C++ code.</p>
<p>The C++ implementation differs from the Fortran implementation in four fundamental ways 1) Custom C++ Array and <a class="el" href="class_vector.html" title="The Vector template class is used for storing int and double data.">Vector</a> classes to reproduce Fortran dynamic arrays 2) XML format file replaces the plain-text input file to specify simulation parameters 3) Direct calls to the VTK API replaces the custom code used to read/write VTK format files 4) Uses 0-based indexing into arrays</p>
<p>What was not converted 1) Shells 2) NURBS 3) Immersed Boundary</p>
<p>The following sections describe how the C++ implementation is organized and how it replicates the data structures and flow of control of the Fortran implementation. Some important details of the C++ implementation will also be discussed.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Code Organization</h1>
<p>The C++ implementation attempts to replicate the data structures and flow of control of the Fortran implementation and to maintains its organization. The svFSI Fortran is about 58K lines of code spread over about 100 files.</p>
<p>Most of the Fortran code is replicated in C++ using the same file and procedure names converted to lower case with underscores to improve readability. For example </p><div class="fragment"><div class="line">================================================================================================</div>
<div class="line">             Fortran                       |                      C++ </div>
<div class="line">================================================================================================</div>
<div class="line">        SUBROUTINE READFILES               |                  read_files()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">        SUBROUTINE READMSH                 |                  read_msh()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            LOADMSH.f                      |                  load_msh.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            VTKXML.f                       |                  vtk_xml.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
</div><!-- fragment --><p>All Fortan procedures located in a particular file will typically have a C++ implementation in a similarly named file. This was done to maintain a simple mapping between the locations of the C++ and Fortran code.</p>
<p>The Fortan svFSI code is implemented using a procedural programming paradigm where data is passed to procedures to carry out a series of computational steps. It makes little or no use of the object orientation features providing by Fortran90. This organization is reproduced in the C++ implementation so there are essentially no class methods used in the core simulation code.</p>
<p>C++ functions are defined within a <code>namespace</code> defined for each Fortran file. For example, the functions in <code>load_msh.cpp</code> are defined within the <code>load_msh</code> <code>namespace</code>. Some <code>namespaces</code> contain a <code>_ns</code> suffix to prevent conflicts with function names (e.g. <code><a class="el" href="namespaceread__files__ns.html" title="Define some types used to pass data to functions.">read_files_ns</a></code>).</p>
<p>All simulation data is stored in the <a href="#simulation_class">Simulation</a> class.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Translating Fortran into C++</h1>
<p>This section provides some details about how the svFSI Fortran code was translated into C++ code. This will help to convert any new Fortran code developed in the Fortan svFSI code not included in svFSIplus.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Variable Names</h2>
<p>svFSIplus is essentially a direct line-by-line translation of the <a href="https://github.com/SimVascular/svFSI">svFSI</a> Fortran code. The original Fortran variable names are typically small, contain no underscores for readability and are often ambiguous. However, the <b>same variable names</b> are used in both the C++ and Fortran codes in order to maintain a clear relationship between them.</p>
<p>For example, the following section of Fortran code </p><div class="fragment"><div class="line">p = 0._rkind</div>
<div class="line"><span class="keywordflow">DO</span> a=1, enonq</div>
<div class="line">   p = p + nq(a)*yl(4,a)</div>
<div class="line"><span class="keywordflow">END DO</span></div>
<div class="line"> </div>
<div class="line">uh = 0._rkind</div>
<div class="line"><span class="keywordflow">IF</span> (mvmsh) <span class="keywordflow">THEN</span></div>
<div class="line">   <span class="keywordflow">DO</span> a=1, enonw</div>
<div class="line">      uh(1) = uh(1) + nw(a)*yl(5,a)</div>
<div class="line">      uh(2) = uh(2) + nw(a)*yl(6,a)</div>
<div class="line">      uh(3) = uh(3) + nw(a)*yl(7,a)</div>
<div class="line"><span class="keywordflow">   END DO</span></div>
<div class="line"><span class="keywordflow">END IF</span></div>
<div class="line">un = (u(1)-uh(1))*nv(1) + (u(2)-uh(2))*nv(2) + (u(3)-uh(3))*nv(3)</div>
<div class="line">un = (abs(un) - un) * 0.5_rkind</div>
<div class="line"> </div>
<div class="line">u(:) = u(:) - ub(:)</div>
<div class="line">ubn  = u(1)*nv(1) + u(2)*nv(2) + u(3)*nv(3)</div>
</div><!-- fragment --><p> is replaced by the following section of C++ code </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> p = 0.0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> a = 0; a &lt; eNoNq; a++) {</div>
<div class="line">  p = p + Nq(a)*yl(3,a);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="class_vector.html">Vector&lt;double&gt;</a> uh(3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (com_mod.mvMsh) {</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> a = 0; a &lt; eNoNw; a++) {</div>
<div class="line">    uh(0) = uh(0) + Nw(a)*yl(4,a);</div>
<div class="line">    uh(1) = uh(1) + Nw(a)*yl(5,a);</div>
<div class="line">    uh(2) = uh(2) + Nw(a)*yl(6,a);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> un = (u(0)-uh(0))*nV(0) + (u(1)-uh(1))*nV(1) + (u(2)-uh(2))*nV(2);</div>
<div class="line">un = (fabs(un) - un) * 0.50;</div>
<div class="line"> </div>
<div class="line">u = u - ub;</div>
<div class="line"><span class="keywordtype">double</span> ubn  = u(0)*nV(0) + u(1)*nV(1) + u(2)*nV(2);</div>
<div class="ttc" id="aclass_vector_html"><div class="ttname"><a href="class_vector.html">Vector&lt; double &gt;</a></div></div>
</div><!-- fragment --><p>In this example the Fortran <code>DO</code> loops are replaced by C++ <code>for</code> loops using C++ 0-based indexing. Array indexing is discussed in the <a href="#translate_arrays">Fortran Dynamic Arrays</a> section below.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Fortran Modules</h2>
<p>Modules were introduced in Fortran to moralize a large code by splitting it into separate files containing procedures and data specific to a certain application. A module is like a C++ class because it can encapsulate both data and procedures. The svFSI Fortran code uses modules primarily to store and access global variables.</p>
<p>C++ classes are used to implement Fortran modules. Fortran variable names are retained to prevent (or maintain) confusion. A C++ module name uses the same Fortan name converted to camel case. For example, several of the Fortan module names and the files that implements them are given below with the corresponding C++ class name and implementation files.</p>
<div class="fragment"><div class="line">================================================================================================</div>
<div class="line">             Fortran Module Name (file)        |                C++ Class Name (file)</div>
<div class="line">================================================================================================</div>
<div class="line">             CEPMOD (CEPMOD.f)                 |               <a class="code" href="class_cep_mod.html">CepMod</a> (<a class="code" href="class_cep_mod.html">CepMod</a>.h,cpp)</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">             CHNLMOD (CHNL.f)                  |               <a class="code" href="class_chnl_mod.html">ChnlMod</a> (<a class="code" href="class_chnl_mod.html">ChnlMod</a>.h,cpp)</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">             COMMOD (MOD.f)                    |               <a class="code" href="class_com_mod.html">ComMod</a> (<a class="code" href="class_com_mod.html">ComMod</a>.h,cpp)</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="ttc" id="aclass_cep_mod_html"><div class="ttname"><a href="class_cep_mod.html">CepMod</a></div><div class="ttdef"><b>Definition:</b> CepMod.h:220</div></div>
<div class="ttc" id="aclass_chnl_mod_html"><div class="ttname"><a href="class_chnl_mod.html">ChnlMod</a></div><div class="ttdef"><b>Definition:</b> ChnlMod.h:101</div></div>
<div class="ttc" id="aclass_com_mod_html"><div class="ttname"><a href="class_com_mod.html">ComMod</a></div><div class="ttdoc">The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....</div><div class="ttdef"><b>Definition:</b> ComMod.h:1310</div></div>
</div><!-- fragment --><p>The Fortan <code>USE</code> command provides access to all the variables defined in a module. Almost all of the svFSI Fortran procedures have a <code>USE COMMOD</code> command that provides access to all of the global variables (about 90) defined in the <code>COMMOD</code> module. For example </p><div class="fragment"><div class="line"><span class="keyword">SUBROUTINE </span>construct_usolid(lM, Ag, Yg, Dg)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">USE </span>commod</div>
<div class="line"><span class="keywordtype">USE </span>allfun</div>
</div><!-- fragment --><p><b>svFSIplus does not use any global variables.</b> A C++ module object is passed to each procedure that needs to access its variables. For example, in C++ the <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> object <code>com_mod</code> is explicitly passed to the <code>construct_usolid</code> function. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> construct_usolid(<a class="code" href="class_com_mod.html">ComMod</a>&amp; com_mod, <a class="code" href="class_cep_mod.html">CepMod</a>&amp; cep_mod, <span class="keyword">const</span> <a class="code" href="classmsh_type.html">mshType</a>&amp; lM, <span class="keyword">const</span> Array&lt;double&gt;&amp; Ag,</div>
<div class="line">    <span class="keyword">const</span> Array&lt;double&gt;&amp; Yg, <span class="keyword">const</span> Array&lt;double&gt;&amp; Dg)</div>
<div class="ttc" id="aclassmsh_type_html"><div class="ttname"><a href="classmsh_type.html">mshType</a></div><div class="ttdoc">This is the container for a mesh or NURBS patch, those specific to NURBS are noted.</div><div class="ttdef"><b>Definition:</b> ComMod.h:788</div></div>
</div><!-- fragment --><p> All C++ modules are stored as member data in the <a href="#simulation_class">Simulation Class</a>.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Fortran Dynamic Arrays</h2>
<p>Fortran dynamic arrays have been reproduced using custom <a href="#array_vector_class">Vector</a>, [Array](array_vector_class) and [<a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a>](array_vector_class) C++ class templates. Note that these user-defined classes will most likely be replaced by a more sophisticated matrix package such as <code>Eigen</code>.</p>
<p>Fortran dynamic arrays are declared using the <code>ALLOCATABLE</code> attribute. For example the <code>REAL, ALLOCATABLE :: A(:,:)</code> statement declares the two dimensional array of type <code>REAL</code> named <code>A</code>. The Fortran <code>ALLOCATE A(3,10)</code> statement then dynamically creates storage for <code>A</code> as a 3x10 array. The <code>DEALLOCATE A</code> statement is used to return the memory used by <code>A</code>. Relocatable arrays are automatically reallocated when going out of scope.</p>
<p>C++ dynamic arrays are declared using the <code>Array&lt;T&gt;</code> template, where T is the array data type: double or int. The two dimensional array of type double named <code>A</code> is declared and memory allocated using <code>Array&lt;double&gt; A(3,10);</code>. Memory is released when <code>A</code> goes out of scope or is explicitly freed using the <code>clear()</code> method.</p>
<p>C++ multidimensional arrays are referenced using 0-based indexing and are traversed in column-major order like Fortran. Array indexes use parenthesis <code>A(i,j)</code> not brackets <code>A[i][j]</code> to access array elements.</p>
<p>For example, the following sections of Fortran code that declare and use dynamics arrays </p><div class="fragment"><div class="line"> <span class="keywordtype">INTEGER(KIND=IKIND)</span>, <span class="keywordtype">ALLOCATABLE</span> :: ptr(:)</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype"> REAL</span>(KIND=rkind), <span class="keywordtype">ALLOCATABLE</span> :: xl(:,:), al(:,:), yl(:,:),</div>
<div class="line">2   bfl(:,:), lr(:,:), lk(:,:,:)</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">ALLOCATE</span>(ptr(enon), xl(nsd,enon), al(tdof,enon), yl(tdof,enon),</div>
<div class="line">2   bfl(nsd,enon), lr(dof,enon), lk(dof*dof,enon,enon))</div>
<div class="line"> </div>
<div class="line"> <span class="comment">! Create local copies</span></div>
<div class="line"> <span class="keywordflow">DO</span> a=1, enon</div>
<div class="line">    ac = lm%IEN(a,e)</div>
<div class="line">    ptr(a)   = ac</div>
<div class="line">    xl(:,a)  = x(:,ac)</div>
<div class="line">    al(:,a)  = ag(:,ac)</div>
<div class="line">    yl(:,a)  = yg(:,ac)</div>
<div class="line">    bfl(:,a) = bf(:,ac)</div>
<div class="line"> <span class="keyword">END </span>DO</div>
</div><!-- fragment --><p> are replaced by the following section of C++ code </p><div class="fragment"><div class="line"><a class="code" href="class_vector.html">Vector&lt;int&gt;</a> ptr(eNoN);</div>
<div class="line">Array&lt;double&gt; xl(nsd,eNoN), al(tDof,eNoN), yl(tDof,eNoN), bfl(nsd,eNoN), lR(dof,eNoN);</div>
<div class="line"><a class="code" href="class_array3.html">Array3&lt;double&gt;</a> lK(dof*dof,eNoN,eNoN);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create local copies</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> a = 0; a &lt; eNoN; a++) {</div>
<div class="line">  <span class="keywordtype">int</span> Ac = lM.<a class="code" href="classmsh_type.html#af675d03d8fbfe19bbf7e1cdd2a6db639">IEN</a>(a,e);</div>
<div class="line">  ptr(a) = Ac;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nsd; i++) {</div>
<div class="line">    xl(i,a) = x(i,Ac);               </div>
<div class="line">    bfl(i,a) = Bf(i,Ac);</div>
<div class="line">  }</div>
<div class="line">    </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tDof; i++) {</div>
<div class="line">    al(i,a) = Ag(i,Ac);</div>
<div class="line">    yl(i,a) = Yg(i,Ac);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_array3_html"><div class="ttname"><a href="class_array3.html">Array3&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassmsh_type_html_af675d03d8fbfe19bbf7e1cdd2a6db639"><div class="ttname"><a href="classmsh_type.html#af675d03d8fbfe19bbf7e1cdd2a6db639">mshType::IEN</a></div><div class="ttdeci">Array&lt; int &gt; IEN</div><div class="ttdoc">The connectivity array mapping eNoN,nEl --&gt; nNo.</div><div class="ttdef"><b>Definition:</b> ComMod.h:885</div></div>
</div><!-- fragment --><p>Note that the <code>:</code> array operator used to copy a column of an array is part of the Fortran language. It was not always possible to efficiently (i.e. memory-to-memory copy) and cleanly replace Fortran array operators by C++ Array template methods. In the above example the Fortran <code>:</code> operator was replaced in C++ by an explicit <code>for</code> loop.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Simulation Class</h1>
<p>The C++ <a href="https://github.com/SimVascular/svFSIplus/blob/main/Code/Source/svFSI/Simulation.h">Simulation</a> class encapsulates all of the objects (Fortran modules) used to store simulation data. It also contains a <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> object used to store simulation parameters read in from an XML file.</p>
<p>The <code><a class="el" href="class_simulation.html">Simulation</a></code> class does not contain any methods used in the core simulation code. Like the Fortan svFSI code it is only used to pass data to procedures to carry out a series of computational steps.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Array and Vector Class Templates</h1>
<p>Fortran dynamic arrays have been reproduced using custom <code><a class="el" href="class_vector.html" title="The Vector template class is used for storing int and double data.">Vector</a></code>, <code>Array</code> and <code><a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a></code> C++ class templates. Note that these custom class templates will most likely be replaced by a more sophisticated matrix package such as <code>Eigen</code>.</p>
<p>The class templates are able to reproduce much of the functionality of Fortran arrays and array intrinsic functions (e.g. sum). The challenge is to create class methods that are as efficient as the Fortan array operators. Because the operators are part of the Fortran language the compiler can optimize them as a efficient memory-to-memory copies. For example </p><div class="fragment"><div class="line">a(:,n) = b(:,n)</div>
<div class="line">a = b</div>
</div><!-- fragment --><p>The objects created from class templates are not part of the C++ language like arrays (i.e. double A[100]). They have the overhead associated with all C++ objects (construct/destroy). Object copy and assignment operators must also be handled efficiently so that intermediate objects are not created and extra data copys are avoided.</p>
<p>The <code><a class="el" href="class_vector.html" title="The Vector template class is used for storing int and double data.">Vector</a></code>, <code>Array</code> and <code><a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a></code> class templates have a <code>data()</code> method that returns a point to the object's internal memory. This is need for MPI calls that take raw C pointers as arguments. For example </p><div class="fragment"><div class="line">MPI_Allreduce(part.data(), tmpI.data(), gnNo, cm_mod::mpint, MPI_MAX, cm.com());</div>
</div><!-- fragment --><p>The class templates are defined in the <a href="https://github.com/SimVascular/svFSIplus/blob/main/Code/Source/svFSI/Vector.h">Vector.h</a>, <a href="https://github.com/SimVascular/svFSIplus/blob/main/Code/Source/svFSI/Array.h">Array.h</a> and <a href="https://github.com/SimVascular/svFSIplus/blob/main/Code/Source/svFSI/Array3.h">Array3.h</a> files.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Allocating and Freeing Memory</h2>
<p>Objects can be created using its constructor </p><div class="fragment"><div class="line">Array&lt;double&gt; A(2,2);</div>
</div><!-- fragment --><p> or defined and later resized </p><div class="fragment"><div class="line">Array&lt;double&gt; A;</div>
<div class="line"> </div>
<div class="line">A.resize(2,2);</div>
</div><!-- fragment --><p>Object memory is initialized to 0.</p>
<p>An object's memory is freed using its <code>clear()</code> method </p><div class="fragment"><div class="line">Array&lt;double&gt; A(2,2)</div>
<div class="line"> </div>
<div class="line">A.clear();</div>
</div><!-- fragment --><p> or when it goes out of scope.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Indexing and Memory Layout</h2>
<p>C++ multidimensional arrays are referenced using 0-based indexing and are traversed in column-major order like Fortran. Array indexes use parenthesis <code>A(i,j)</code> not brackets <code>A[i][j]</code> to access array elements. This was done to make C++ code look more like Fortran and to simplify the conversion process. </p><div class="fragment"><div class="line"><a class="code" href="class_vector.html">Vector&lt;double&gt;</a> u(2);</div>
<div class="line">Array&lt;double&gt; ux(2,2);</div>
<div class="line"><a class="code" href="class_array3.html">Array3&lt;double&gt;</a> uxx(2,2,2);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> a = 0; a &lt; eNoNw; a++) {</div>
<div class="line">  ud(0) = ud(0) + Nw(a)*(al(0,a)-bfl(0,a));</div>
<div class="line">  ud(1) = ud(1) + Nw(a)*(al(1,a)-bfl(1,a));</div>
<div class="line"> </div>
<div class="line">  u(0) = u(0) + Nw(a)*yl(0,a);</div>
<div class="line">  u(1) = u(1) + Nw(a)*yl(1,a);</div>
<div class="line"> </div>
<div class="line">  ux(0,0) = ux(0,0) + Nwx(0,a)*yl(0,a);</div>
<div class="line">  ux(1,0) = ux(1,0) + Nwx(1,a)*yl(0,a);</div>
<div class="line">  ux(0,1) = ux(0,1) + Nwx(0,a)*yl(1,a);</div>
<div class="line">  ux(1,1) = ux(1,1) + Nwx(1,a)*yl(1,a);</div>
<div class="line"> </div>
<div class="line">  uxx(0,0,0) = uxx(0,0,0) + Nwxx(0,a)*yl(0,a);</div>
<div class="line">  uxx(1,0,1) = uxx(1,0,1) + Nwxx(1,a)*yl(0,a);</div>
<div class="line">  uxx(1,0,0) = uxx(1,0,0) + Nwxx(2,a)*yl(0,a);</div>
<div class="line"> </div>
<div class="line">  uxx(0,1,0) = uxx(0,1,0) + Nwxx(0,a)*yl(1,a);</div>
<div class="line">  uxx(1,1,1) = uxx(1,1,1) + Nwxx(1,a)*yl(1,a);</div>
<div class="line">  uxx(1,1,0) = uxx(1,1,0) + Nwxx(2,a)*yl(1,a);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Indexes can be checked by defining the <code>_check_enabled</code> directive within each template include file. An index out of bounds will throw an <code>std::runtime_error</code> exception. Note that index checking will substantially slow down a simulation so it should be disabled when not testing.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Operators</h2>
<p>Class templates support most mathematical operators: =,+,-,*,/,+=</p>
<p>Some Fortran array intrinsic (e.g. abs, sqrt) are also supported.</p>
<p>Example </p><div class="fragment"><div class="line">Array&lt;double&gt; Wr(dof,nNo), Wc(dof,nNo);</div>
<div class="line"> </div>
<div class="line">Wr = 1.0;</div>
<div class="line"> </div>
<div class="line">Wr = Wr - 0.5;</div>
<div class="line">Wr = Wr / abs(Wr);</div>
<div class="line">Wr = (Wr + abs(Wr)) * 0.5;</div>
<div class="line"> </div>
<div class="line">Wc = 1.0 / sqrt(Wc);</div>
<div class="line"> </div>
<div class="line">W1 = W1 * Wr;</div>
<div class="line">W2 = W2 * Wc;</div>
</div><!-- fragment --><p>The Array <code>*</code> operator performs an element-by-element multiplication, not a matrix multiplication. This was done to replicate Fortran.</p>
<p>It is more efficient to use the <code>+=</code> operator <code>A += B</code> than <code>A = A + B</code> which performs a copy.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Getting an Array Column</h2>
<p>A lot of Fortran code in svFSI operates on a column of a 2D array. For example </p><div class="fragment"><div class="line"><span class="comment">CALL FLUID3D_M(vmsStab, fs(1)%eNoN, fs(2)%eNoN, w, ksix,</span></div>
<div class="line">     2            fs(1)%N(:,g), fs(2)%N(:,g), nwx, nqx, nwxx, al, yl,</div>
<div class="line">     3            bfl, lr, lk)</div>
</div><!-- fragment --><p> where <code>fs(1)N(:,g)</code> gets the column <code>g</code> of the <code>fs(2)N</code> array.</p>
<p>The operation of getting a column of data from an Array object is supported using two different methods </p><div class="fragment"><div class="line"><a class="code" href="class_vector.html">Vector&lt;T&gt;</a> col(<span class="keyword">const</span> <span class="keywordtype">int</span> col, <span class="keyword">const</span> std::array&lt;int,2&gt;&amp; range={-1,-1}) <span class="keyword">const</span> - Returns a <span class="keyword">new</span> <a class="code" href="class_vector.html">Vector&lt;T&gt;</a> <span class="keywordtype">object</span> containing a copy of the column data.</div>
<div class="line"> </div>
<div class="line">Vector&lt;T&gt; rcol(<span class="keyword">const</span> <span class="keywordtype">int</span> col) <span class="keyword">const</span> - Returns a <span class="keyword">new</span> <a class="code" href="class_vector.html">Vector&lt;T&gt;</a> <span class="keywordtype">object</span> containing an address pointing into the Array <span class="keyword">internal</span> data. Modifying the <a class="code" href="class_vector.html">Vector&lt;T&gt;</a> <span class="keywordtype">object</span><span class="stringliteral">&#39;s data modifies the orginal Array data.</span></div>
</div><!-- fragment --><p>Use the <code>col</code> method if the column data is not going to be modified </p><div class="fragment"><div class="line"><span class="keyword">auto</span> N0 = fs[0].N.col(g);</div>
<div class="line"><span class="keyword">auto</span> N1 = fs[1].N.col(g);</div>
<div class="line">fluid_3d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK);</div>
</div><!-- fragment --><p>Use the <code>rcol</code> method if the column data is going to be modified; it might also help to speed up a procedure that is called a lot (e.g. in material models).</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Getting an Array3 Slice</h2>
<p>A lot of Fortran code in svFSI operates on a slice (a 2D sub-array) of a 3D array. For example </p><div class="fragment"><div class="line"><span class="comment">CALL GNN(fs(1)%eNoN, nsd, fs(1)%Nx(:,:,g), xwl, Nwx, Jac, ksix)</span></div>
</div><!-- fragment --><p> where <code>fs(1)Nx(:,:,g)</code> gets a slice (2D sub-array) <code>g</code> of the <code>fs(1)Nx</code> array.</p>
<p>The operation of getting a slice of data from an <a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a> object is supported using two different methods </p><div class="fragment"><div class="line">Array&lt;T&gt; slice(<span class="keyword">const</span> <span class="keywordtype">int</span> slice) <span class="keyword">const</span> - Returns a <span class="keyword">new</span> Array&lt;T&gt; <span class="keywordtype">object</span> containing a copy of the slice data.</div>
<div class="line">Array&lt;T&gt; rslice(<span class="keyword">const</span> <span class="keywordtype">int</span> slice) <span class="keyword">const</span> - Return an Array&lt;T&gt; <span class="keywordtype">object</span> with data pointing into the <a class="code" href="class_array3.html">Array3</a> <span class="keyword">internal</span> data.</div>
</div><!-- fragment --><p>The <code>rslice()</code> method returns an <code>Array</code> object whose internal data is a pointer to the internal data of an <code><a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a></code> object. This was done to reduce the overhead of copying sub-arrays in some sections of the custom linear algebra code. The <code>Array</code> object will not free its data if it is a reference to the data of a <code><a class="el" href="class_array3.html" title="The Array3 template class implements a simple interface to 3D arrays.">Array3</a></code> object. Use the <code>rslice</code> method if the slice data is going to be modified. It can also speed up code that repeatedly extracts sub-arrays used in computations but are not modified.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Fortran 0-size Arrays</h2>
<p>The Fortran code made use of 0-size arrays in several places, using <code>ALLOCATE</code> with a zero size. For some reason Fortran is OK with using these 0-size arrays.</p>
<p>The C++ code reproduces this by allowing <code>Array</code> objects to be allocated with 0 size rows and columns. This is a total hack but it allowed to get the C++ code working without having to rewrite a lot of code.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
Solver Parameter Input XML File</h1>
<p>The Fortan svFSI solver read in simulation parameters in a custom text format. All parameters were read in at startup and stored as an array of characters (string) using custom code. <a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a> values were then retrieved during various stages of the computation. The string representation was converted when the value of a parameter was needed. An error in a parameter value could therefore not be detected until later stages of the computation (e.g., when the mesh is being distributed over processors).</p>
<p>svFSIplus solver simulation parameters are stored in the Extensible Markup Language (XML) file format. XML is a simple text-based format for representing structured data as element tree. The XML tree starts at a root element and branches from the root to sub-elements. All elements can have sub-elements. An XML tag is a markup construct that begins with &lt; and ends with &gt;. There are three types of tag: 1) start-tag, such as <code>&lt;section&gt;</code> 2) end-tag, such as <code>&lt;/section&gt;</code> 3) empty-element tag, such as <code>&lt;line-break /&gt;</code></p>
<p>XML <em>tags</em> represent data structures and contain metadata. An XML <em>element</em> is a logical component that either begins with a start-tag and ends with a matching end-tag or consists only of an empty-element tag. The characters between the start-tag and end-tag, if any, are the element's <em>content</em>, and may contain markup, including other elements, which are called child elements. An <em>attribute</em> is a markup construct consisting of a nameâ€“value pair that exists within a start-tag or empty-element tag.</p>
<p>Example: </p><div class="fragment"><div class="line">&lt;svFSIFile&gt; |--------------------------------------------- root element</div>
<div class="line">  &lt;Add_equation type=<span class="stringliteral">&quot;FSI&quot;</span> &gt;   |-------------------------- start-tag with an attribute named type</div>
<div class="line">  &lt;Coupled&gt; <span class="keyword">true</span> &lt;/Coupled&gt;    |--------------------------- Coupled element with data <span class="keyword">true</span></div>
<div class="line">  &lt;Min_iterations&gt; 1 &lt;/Min_iterations&gt;</div>
<div class="line">  &lt;Max_iterations&gt; 1 &lt;/Max_iterations&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;Tolerance&gt; 1e-6 &lt;/Tolerance&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;Domain <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span> &gt;    |----------------------------- Domain element with several child elements</div>
<div class="line">     &lt;Equation&gt; fluid &lt;/Equation&gt;</div>
<div class="line">     &lt;Density&gt; 1.0 &lt;/Density&gt;</div>
<div class="line">     &lt;Viscosity model=<span class="stringliteral">&quot;Constant&quot;</span> &gt;</div>
<div class="line">        &lt;Value&gt; 0.04 &lt;/Value&gt;</div>
<div class="line">     &lt;/Viscosity&gt;</div>
<div class="line">     &lt;Backflow_stabilization_coefficient&gt; 0.2 &lt;/Backflow_stabilization_coefficient&gt;</div>
<div class="line">  &lt;/Domain&gt;</div>
<div class="line"> </div>
<div class="line">&lt;/svFSIFile&gt;</div>
</div><!-- fragment --><p>The elements in the svFSIplus simulation file are represented by <em>sections</em> of related parameters. Sub-elements are referred to as <em>sub-sections</em>. The svFSIplus simulation file has four top-level sections </p><div class="fragment"><div class="line">1) General</div>
<div class="line">2) Mesh</div>
<div class="line">3) Equation</div>
<div class="line">4) Projection</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Parameters class</h2>
<p>The <a href="https://github.com/SimVascular/svFSIplus/blob/main/Code/Source/svFSI/Parameters.h">Parameters</a> class is used to read and store simulation parameters parsed from an XML file using using <a href="https://github.com/leethomason/tinyxml2">tinyxml2</a>. <a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a> types are checked as they are read so errors in parameter values are immediately detected.</p>
<p>The <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> class contains objects for each of the top-level sections in the parameters file </p><div class="fragment"><div class="line"><a class="code" href="class_general_simulation_parameters.html">GeneralSimulationParameters</a> general_simulation_parameters;</div>
<div class="line">std::vector&lt;MeshParameters*&gt; mesh_parameters;</div>
<div class="line">std::vector&lt;EquationParameters*&gt; equation_parameters;</div>
<div class="line">std::vector&lt;ProjectionParameters*&gt; projection_parameters;</div>
<div class="ttc" id="aclass_general_simulation_parameters_html"><div class="ttname"><a href="class_general_simulation_parameters.html">GeneralSimulationParameters</a></div><div class="ttdoc">The GeneralSimulationParameters class stores paramaters for the 'GeneralSimulationParameters' XML ele...</div><div class="ttdef"><b>Definition:</b> Parameters.h:1210</div></div>
</div><!-- fragment --><p>Each section is represented as a class containing objects for the parameters defined for that section and objects representing any sub-sections. Objects representing parameters are named the same as the name used in the XML file except with a lower case first character. Each parameter has a name and a value with as a basic type (bool, double, int, etc.) using the <code><a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a></code> template class.</p>
<p>Example: <a class="el" href="class_mesh_parameters.html" title="The MeshParameters class is used to store paramaters for the &#39;Add_mesh&#39; XML element.">MeshParameters</a> class parameter objects </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="class_mesh_parameters.html">MeshParameters</a> : <span class="keyword">public</span> <a class="code" href="class_parameter_lists.html">ParameterLists</a></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="class_parameter.html">Parameter&lt;std::string&gt;</a> name;                       <span class="comment">// &lt;Add_mesh name=NAME &gt;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="class_parameter.html">Parameter&lt;bool&gt;</a> initialize_rcr_from_flow;          <span class="comment">// &lt;Initialize_RCR_from_flow&gt; BOOL &lt;/Initialize_RCR_from_flow&gt;</span></div>
<div class="line"> </div>
<div class="line">    <a class="code" href="class_parameter.html">Parameter&lt;std::string&gt;</a> mesh_file_path;             <span class="comment">// &lt;Mesh_file_path&gt; FILE_NAME &lt;/Mesh_file_path&gt;</span></div>
<div class="line">    </div>
<div class="line">    <a class="code" href="class_parameter.html">Parameter&lt;double&gt;</a> mesh_scale_factor;               <span class="comment">// &lt;Mesh_scale_factor&gt; SCALE &lt;/Mesh_scale_factor&gt;</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_mesh_parameters_html"><div class="ttname"><a href="class_mesh_parameters.html">MeshParameters</a></div><div class="ttdoc">The MeshParameters class is used to store paramaters for the 'Add_mesh' XML element.</div><div class="ttdef"><b>Definition:</b> Parameters.h:1296</div></div>
<div class="ttc" id="aclass_parameter_html"><div class="ttname"><a href="class_parameter.html">Parameter&lt; std::string &gt;</a></div></div>
<div class="ttc" id="aclass_parameter_lists_html"><div class="ttname"><a href="class_parameter_lists.html">ParameterLists</a></div><div class="ttdoc">Defines parameter name and value, and stores them in maps for settng values from XML.</div><div class="ttdef"><b>Definition:</b> Parameters.h:289</div></div>
</div><!-- fragment --><p>All section classes inherit from the <code><a class="el" href="class_parameter_lists.html" title="Defines parameter name and value, and stores them in maps for settng values from XML.">ParameterLists</a></code> class which has methods to set parameter values and store them in a map for processing (e.g. checking that all required parameters have been set).</p>
<p><a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a> names and default values are set in each section object constructor using member data. The <code><a class="el" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488" title="Set the name, default value and the parameter required flag.">ParameterLists::set_parameter()</a></code> sets the name and default value for a parameter, and if a value for it is required to be given in the XML file.</p>
<p>Example: Setting parameter names and values in the <a class="el" href="class_mesh_parameters.html" title="The MeshParameters class is used to store paramaters for the &#39;Add_mesh&#39; XML element.">MeshParameters</a> constructor </p><div class="fragment"><div class="line">MeshParameters::MeshParameters()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> required = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Domain&quot;</span>, 0,  !required, domain_id);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Domain_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, !required, domain_file_path);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Fiber_direction_file_path&quot;</span>, {}, !required, fiber_direction_file_paths);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Mesh_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, required, mesh_file_path);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Mesh_scale_factor&quot;</span>, 1.0, !required, mesh_scale_factor);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Prestress_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, !required, prestress_file_path);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Initial_displacements_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, !required, initial_displacements_file_path);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Initial_pressures_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, !required, initial_pressures_file_path);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Initial_velocities_file_path&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, !required, initial_velocities_file_path);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Set_mesh_as_fibers&quot;</span>, <span class="keyword">false</span>, !required, set_mesh_as_fibers);</div>
<div class="line">  <a class="code" href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">set_parameter</a>(<span class="stringliteral">&quot;Set_mesh_as_shell&quot;</span>, <span class="keyword">false</span>, !required, set_mesh_as_shell);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_parameter_lists_html_a26a80343e9bfb925b217331a1188f488"><div class="ttname"><a href="class_parameter_lists.html#a26a80343e9bfb925b217331a1188f488">ParameterLists::set_parameter</a></div><div class="ttdeci">void set_parameter(const std::string &amp;name, const bool value, bool required, Parameter&lt; bool &gt; &amp;param)</div><div class="ttdoc">Set the name, default value and the parameter required flag.</div><div class="ttdef"><b>Definition:</b> Parameters.h:300</div></div>
</div><!-- fragment --><p><a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a> values are set using the 'set_values()' method which contains calls to tinyxml2 to parse parameter values from an XML file. The XML elements within a section are extracted in a while loop. Sub-sections or data will need to be checked and processed. The '<a class="el" href="class_parameter_lists.html#a5840a4ed175edcc4e3c3193182bcaa7a" title="Set the value of a paramter from a string.">ParameterLists::set_parameter_value()</a>' method is used to set the value of a parameter from a string.</p>
<p>Example: Parsing XML and setting parameter values in MeshParameters::set_values() </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MeshParameters::set_values(tinyxml2::XMLElement* mesh_elem)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>tinyxml2;</div>
<div class="line">  std::string error_msg = <span class="stringliteral">&quot;Unknown &quot;</span> + <a class="code" href="class_mesh_parameters.html#a442461e2c1aaee3679e39b2bf5abc302">xml_element_name_</a> + <span class="stringliteral">&quot; XML element &#39;&quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> item = mesh_elem-&gt;FirstChildElement();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (item != <span class="keyword">nullptr</span>) {</div>
<div class="line">    <span class="keyword">auto</span> name = std::string(item-&gt;Value());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add_face sub-section.</span></div>
<div class="line">    <span class="keywordflow">if</span> (name == <a class="code" href="class_face_parameters.html#a154d2fbee15ca4db7addae9815bd9023">FaceParameters::xml_element_name_</a>) {         <span class="comment">// &lt;Add_face name=NAME&gt;</span></div>
<div class="line">      <span class="keyword">auto</span> face_params = <span class="keyword">new</span> <a class="code" href="class_face_parameters.html">FaceParameters</a>();</div>
<div class="line">      face_params-&gt;set_values(item);</div>
<div class="line">      face_parameters.push_back(face_params);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// There may be multiple &#39;Fiber_direction&#39; elements so store</span></div>
<div class="line">    <span class="comment">// them as a list of VectorParameter&lt;double&gt;. </span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;Fiber_direction&quot;</span>) {                   <span class="comment">// &lt;Fiber_direction&gt; (x, y, z)  &lt;/Fiber_direction&gt;</span></div>
<div class="line">      <span class="keyword">auto</span> value = item-&gt;GetText();</div>
<div class="line">      <a class="code" href="class_vector_parameter.html">VectorParameter&lt;double&gt;</a> dir(<span class="stringliteral">&quot;Fiber_direction&quot;</span>, {}, <span class="keyword">false</span>, {});</div>
<div class="line">      dir.<a class="code" href="class_vector_parameter.html#a698947d103b7a4483f767e162a3da73d">set</a>(value);</div>
<div class="line">      fiber_directions.push_back(dir);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Just a simple element. </span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (item-&gt;GetText() != <span class="keyword">nullptr</span>) {                  <span class="comment">// &lt;Mesh_file_path&gt;, &lt;Mesh_scale_factor&gt;, &lt;Domain&gt;, etc.</span></div>
<div class="line">      <span class="keyword">auto</span> value = item-&gt;GetText();</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code" href="class_parameter_lists.html#a5840a4ed175edcc4e3c3193182bcaa7a">set_parameter_value</a>(name, value);</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_function_call&amp; exception) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(error_msg + name + <span class="stringliteral">&quot;&#39;.&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">throw</span> std::runtime_error(error_msg + name + <span class="stringliteral">&quot;&#39;.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    item = item-&gt;NextSiblingElement();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_face_parameters_html"><div class="ttname"><a href="class_face_parameters.html">FaceParameters</a></div><div class="ttdoc">The FaceParameters class is used to store parameters for the 'Add_face' XML element.</div><div class="ttdef"><b>Definition:</b> Parameters.h:1256</div></div>
<div class="ttc" id="aclass_face_parameters_html_a154d2fbee15ca4db7addae9815bd9023"><div class="ttname"><a href="class_face_parameters.html#a154d2fbee15ca4db7addae9815bd9023">FaceParameters::xml_element_name_</a></div><div class="ttdeci">static const std::string xml_element_name_</div><div class="ttdoc">Process parameters for the 'Add_face' XML element.</div><div class="ttdef"><b>Definition:</b> Parameters.h:1263</div></div>
<div class="ttc" id="aclass_mesh_parameters_html_a442461e2c1aaee3679e39b2bf5abc302"><div class="ttname"><a href="class_mesh_parameters.html#a442461e2c1aaee3679e39b2bf5abc302">MeshParameters::xml_element_name_</a></div><div class="ttdeci">static const std::string xml_element_name_</div><div class="ttdoc">Define the XML element name for mesh parameters.</div><div class="ttdef"><b>Definition:</b> Parameters.h:1300</div></div>
<div class="ttc" id="aclass_parameter_lists_html_a5840a4ed175edcc4e3c3193182bcaa7a"><div class="ttname"><a href="class_parameter_lists.html#a5840a4ed175edcc4e3c3193182bcaa7a">ParameterLists::set_parameter_value</a></div><div class="ttdeci">void set_parameter_value(const std::string &amp;name, const std::string &amp;value)</div><div class="ttdoc">Set the value of a paramter from a string.</div><div class="ttdef"><b>Definition:</b> Parameters.h:344</div></div>
<div class="ttc" id="aclass_vector_parameter_html"><div class="ttname"><a href="class_vector_parameter.html">VectorParameter&lt; double &gt;</a></div></div>
<div class="ttc" id="aclass_vector_parameter_html_a698947d103b7a4483f767e162a3da73d"><div class="ttname"><a href="class_vector_parameter.html#a698947d103b7a4483f767e162a3da73d">VectorParameter::set</a></div><div class="ttdeci">void set(const std::string &amp;name, bool required, const std::vector&lt; T &gt; &amp;value)</div><div class="ttdoc">Set the parameter name and value, and if it is required.</div><div class="ttdef"><b>Definition:</b> Parameters.h:238</div></div>
</div><!-- fragment --><p>Sections that contain simple elements (i.e., no sub-sections or special data processing) can be automatically parsed.</p>
<p>Example: Automatically parsing XML and setting parameter values in <code>LinearSolverParameters::set_values(tinyxml2::XMLElement* xml_elem)</code> </p><div class="fragment"><div class="line">  std::string error_msg = <span class="stringliteral">&quot;Unknown &quot;</span> + xml_element_name + <span class="stringliteral">&quot; XML element &#39;&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the &#39;type&#39; from the &lt;LS type=TYPE&gt; element.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* stype;</div>
<div class="line"><span class="keyword">auto</span> result = xml_elem-&gt;QueryStringAttribute(<span class="stringliteral">&quot;type&quot;</span>, &amp;stype);</div>
<div class="line"><span class="keywordflow">if</span> (stype == <span class="keyword">nullptr</span>) {</div>
<div class="line">  <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;No TYPE given in the XML &lt;LStype=TYPE&gt; element.&quot;</span>);</div>
<div class="line">}</div>
<div class="line">type.set(std::string(stype));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> std::placeholders::_1;</div>
<div class="line"><span class="keyword">using</span> std::placeholders::_2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a function pointer &#39;fptr&#39; to &#39;LinearSolverParameters::set_parameter_value&#39;.</span></div>
<div class="line">std::function&lt;void(<span class="keyword">const</span> std::string&amp;, <span class="keyword">const</span> std::string&amp;)&gt; ftpr =</div>
<div class="line">    std::bind( &amp;<a class="code" href="class_parameter_lists.html#a5840a4ed175edcc4e3c3193182bcaa7a">LinearSolverParameters::set_parameter_value</a>, *<span class="keyword">this</span>, _1, _2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse XML and set parameter values.</span></div>
<div class="line">xml_util_set_parameters(ftpr, xml_elem, error_msg);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Accessing Parameters</h2>
<p><a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a> values are accessed from the core simulation code using the <code><a class="el" href="class_simulation.html">Simulation</a></code> object's <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> object. The <code><a class="el" href="class_parameter.html" title="The Parameter class template is used to store a named paramater and its scalar value as a basic type:...">Parameter</a></code> template class <code>()</code> operator or <code>value()</code> method is used to access the parameter's value, the <code>defined()</code> method is used to check if a parameter's value has been set.</p>
<p>Example: Accessing parameter values </p><div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; general_params = simulation-&gt;parameters.general_simulation_parameters</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> nsd = general_params.number_of_spatial_dimensions();</div>
<div class="line"><span class="keyword">auto</span> file_path = simulation.parameters.mesh_parameters[0].mesh_file_path();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (eq_params-&gt;variable_wall_properties.defined()) { }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md24"></a>
Performance and Accuracy</h1>
<p>Performance</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Potential Problems</h1>
<p>The following sections briefly outline some problems that might cause simulation failures or incorrect results.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Indexing Mistakes</h2>
<p>There may still be indexing mistakes</p><ul>
<li>Numeric index is off by one</li>
<li>Offsets into arrays may not be correct</li>
</ul>
<p>There are a lot places in the code that uses indexes to offset into arrays.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Fortran 0-size Arrays</h2>
<p>The Fortran code uses of 0-size arrays in several places. The C++ code reproduced this kind of functionality using tests of array size and adding the allocation of 0-sized <code>Array</code> objects. This hack might could fail under certain circumstances.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Implementation Details</h1>
<p>This section covers some of the C++ implementation details that may be useful to developers adding new capabilities to svFSIplus.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
References vs. Pointers</h2>
<p>svFSIPlus does not dynamically allocated objects except in <code>Array</code> and <code><a class="el" href="class_vector.html" title="The Vector template class is used for storing int and double data.">Vector</a></code> classes and C++ containers. All objects defined in module classes are allocated statically and are referenced using a dot. This provided a much cleaner translation from Fortran to C++ by replacing <code>%</code> with <code>.</code>. </p><div class="fragment"><div class="line">msh%fa(iFa)  -&gt;  msh.fa[iFa]</div>
</div><!-- fragment --><p>Access objects as references to avoid copying </p><div class="fragment"><div class="line">const auto&amp; meshes = com_mod.msh;</div>
<div class="line">auto&amp; cm = com_mod.cm;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Constants</h2>
<p>In svFSI constants are defined in the <code>CONSTS.f</code> file using the Fortan <code>PARAMETER</code> statement </p><div class="fragment"><div class="line"><span class="comment">!     Types of equations that are included in this solver</span></div>
<div class="line"><span class="comment">!     Fluid equation (Navier-Stokes), nonlinear structure (pure d), heat</span></div>
<div class="line"><span class="comment">!     equation, linear elasticity, heat in fluid (advection-diffusion),</span></div>
<div class="line"><span class="comment">!     fluid-structure-interaction, mesh motion, Shell mechanics,</span></div>
<div class="line"><span class="comment">!     Coupled-Momentum-Method, Cardiac Electro-Physiology,</span></div>
<div class="line"><span class="comment">!     Nonlinear structure (v-p), Stokes equations</span></div>
<div class="line">      <span class="keywordtype">INTEGER(KIND=IKIND)</span>, <span class="keywordtype">PARAMETER</span> :: phys_NA = 200, phys_fluid = 201,</div>
<div class="line">     2   phys_struct = 202, phys_heats = 203, phys_lelas = 204,</div>
<div class="line">     3   phys_heatf = 205, phys_fsi = 206, phys_mesh = 207,</div>
<div class="line">     4   phys_shell = 208, phys_cmm = 209, phys_cep = 210,</div>
<div class="line">     5   phys_ustruct = 211, phys_stokes = 212</div>
</div><!-- fragment --><p>svFSIplus uses <code>enum class</code> types defined in <code><a class="el" href="consts_8h_source.html">consts.h</a></code> </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> EquationType</div>
<div class="line">{ </div>
<div class="line">  phys_NA = 200, </div>
<div class="line">  phys_fluid = 201,</div>
<div class="line">  phys_struct = 202,  <span class="comment">// nonlinear structure (pure d)</span></div>
<div class="line">  phys_heatS = 203,</div>
<div class="line">  phys_lElas = 204,</div>
<div class="line">  phys_heatF = 205,</div>
<div class="line">  phys_FSI = 206,     </div>
<div class="line">  phys_mesh = 207,    <span class="comment">// solves a modified lElas for mesh motion; should be used with FSI</span></div>
<div class="line">  phys_shell = 208,   <span class="comment">// solves nonlinear thin shell mechanics (Kirchhoff-Love theory)</span></div>
<div class="line">  phys_CMM = 209,</div>
<div class="line">  phys_CEP = 210,</div>
<div class="line">  phys_ustruct = 211,  <span class="comment">// Nonlinear elastodynamics using mixed VMS-stabilized formulation </span></div>
<div class="line">  phys_stokes = 212</div>
<div class="line">};</div>
</div><!-- fragment --><p>Constants are accessed using </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>consts;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ((dmn.phys == EquationType::phys_fluid) ||</div>
<div class="line">    (dmn.phys == EquationType::phys_stokes) ||</div>
<div class="line">    (dmn.phys == EquationType::phys_CMM &amp;&amp; !com_mod.<a class="code" href="class_com_mod.html#a809d9ea8cc83b2bd205cc858cfecda47">cmmInit</a>)) {</div>
<div class="line">  dist_visc_model(com_mod, cm_mod, cm, dmn.visc);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_com_mod_html_a809d9ea8cc83b2bd205cc858cfecda47"><div class="ttname"><a href="class_com_mod.html#a809d9ea8cc83b2bd205cc858cfecda47">ComMod::cmmInit</a></div><div class="ttdeci">bool cmmInit</div><div class="ttdoc">Whether CMM equation is initialized.</div><div class="ttdef"><b>Definition:</b> ComMod.h:1352</div></div>
</div><!-- fragment --><p>Some constants have a short-hand representation </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> Equation_CMM = EquationType::phys_CMM;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_CEP = EquationType::phys_CEP;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_fluid = EquationType::phys_fluid;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_FSI = EquationType::phys_FSI;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_heatF = EquationType::phys_heatF;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_heatS = EquationType::phys_heatS;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_lElas = EquationType::phys_lElas;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_mesh = EquationType::phys_mesh;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_shell = EquationType::phys_shell;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_stokes = EquationType::phys_stokes;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_struct = EquationType::phys_struct;</div>
<div class="line">constexpr <span class="keyword">auto</span> Equation_ustruct = EquationType::phys_ustruct;</div>
</div><!-- fragment --><p>which are used like this </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((eq.phys == Equation_CMM) &amp;&amp; com_mod.<a class="code" href="class_com_mod.html#a809d9ea8cc83b2bd205cc858cfecda47">cmmInit</a>) { </div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md31"></a>
Coding Standards</h1>
<p>This section describes the coding standards and guidelines that must be followed when adding new code to svFSIplus.</p>
<p>Coding standards are important for producing good software</p>
<ul>
<li>Gives a uniform appearance to the code written by different developers</li>
<li>Improves readability and maintainability</li>
<li>Helps in code reuse and to detect errors</li>
<li>Promotes sound programming practices and increases programmer efficiency</li>
</ul>
<p>Code that does not follow coding standards will be rejected during code review. However, program structures not mentioned in the following sections may be coded in any (non-hideous) manner favoured by the developer.</p>
<p>Note that svFSIplus maintained the program structure and naming conventions used by the svFSI Fortran code so some of the following coding standards may be violated.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Indentation</h2>
<p>Indentation refers to the spaces at the beginning of a code line. It is a fundamental aspect of code styling and improves readability by showing the overall structure of the code.</p>
<p>Indentation is two spaces for all programming structures: functions, loops, if-then blocks, etc. Do not use tabs to indent.</p>
<p>The <b>if-else</b> class of statements should have the following form </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (condition) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (condition) {</div>
<div class="line">  ...</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A <b>for</b> statement should have the following form </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (initialization; condition; update) {</div>
<div class="line">  statements;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A <b>switch</b> statement should have the following form </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span> (condition) {</div>
<div class="line">  <span class="keywordflow">case</span> ABC:</div>
<div class="line">    statements;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">default</span>:</div>
<div class="line">    statements;</div>
<div class="line">  <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The braces indicating a function body are placed in column 1, function body statements are indented by two spaces. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> find_max(<span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">double</span> values[])</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> num_values{0};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">    <span class="keywordflow">if</span> (values[i] != 0.0) {</div>
<div class="line">      num_values += 1;</div>
<div class="line">    }</div>
<div class="line">  }  </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md33"></a>
White Space</h2>
<p>Whitespace is a term that refers to the spaces and newlines that are used to make code more readable.</p>
<p>The following white space conventions should be followed</p><ul>
<li>Assignment operators always have spaces around them.</li>
<li>Other binary operators usually have spaces around them, but itâ€™s OK to remove spaces around *, / and %.</li>
<li>Parentheses should have no internal padding.</li>
<li>No spaces separating unary operators and their arguments.</li>
<li>C++ reserved words should be followed by a white space.</li>
<li>Commas should be followed by a white space.</li>
<li>Colons should be surrounded by white space.</li>
<li>Semicolons in for statements should be followed by a space character.</li>
</ul>
<div class="fragment"><div class="line">v = w * x + y / z;          <span class="comment">// good</span></div>
<div class="line">v = w*x + y/z;              <span class="comment">// also ok</span></div>
<div class="line">v = w * (x + z);            <span class="comment">// good</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {              <span class="comment">// bad   while(true) ...</span></div>
<div class="line">doSomething(a, b, c, d);    <span class="comment">// bad   doSomething(a,b,c,d);</span></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 10; i++) {  <span class="comment">// bad   for (i=0;i&lt;10;i++){</span></div>
</div><!-- fragment --><p>Some complex expressions may be better organized without single separating spaces. The following could be written using spaces between sub-expressions only </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> Inv2 = 0.50 * (Inv1*Inv1 - J4d*<a class="code" href="namespacemat__fun.html#a80fd0b01661fb60e285f4d1a94ad3eeb">mat_trace</a>(<a class="code" href="namespacemat__fun.html#a7f258f8d7f62a92cd85f0b12dd354203">mat_mul</a>(C,C), nsd));</div>
<div class="ttc" id="anamespacemat__fun_html_a7f258f8d7f62a92cd85f0b12dd354203"><div class="ttname"><a href="namespacemat__fun.html#a7f258f8d7f62a92cd85f0b12dd354203">mat_fun::mat_mul</a></div><div class="ttdeci">Vector&lt; double &gt; mat_mul(const Array&lt; double &gt; &amp;A, const Vector&lt; double &gt; &amp;v)</div><div class="ttdoc">Multiply a matrix by a vector.</div><div class="ttdef"><b>Definition:</b> mat_fun.cpp:497</div></div>
<div class="ttc" id="anamespacemat__fun_html_a80fd0b01661fb60e285f4d1a94ad3eeb"><div class="ttname"><a href="namespacemat__fun.html#a80fd0b01661fb60e285f4d1a94ad3eeb">mat_fun::mat_trace</a></div><div class="ttdeci">double mat_trace(const Array&lt; double &gt; &amp;A, const int nd)</div><div class="ttdoc">Trace of second order matrix of rank nd.</div><div class="ttdef"><b>Definition:</b> mat_fun.cpp:618</div></div>
</div><!-- fragment --><p> or written using double spacing between sub-expressions </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> Inv2 = 0.50 * (Inv1 * Inv1  -  J4d * <a class="code" href="namespacemat__fun.html#a80fd0b01661fb60e285f4d1a94ad3eeb">mat_trace</a>(<a class="code" href="namespacemat__fun.html#a7f258f8d7f62a92cd85f0b12dd354203">mat_mul</a>(C,C), nsd));</div>
</div><!-- fragment --><p>Use newlines often to separate logical blocks of code: for-loops, if statements, related code blocks. </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> e = 0; e &lt; lM.<a class="code" href="classmsh_type.html#adaaafdbbe89881032d38cd699aed1031">nEl</a>; e++) {</div>
<div class="line">  <span class="keywordtype">int</span> iDmn = all_fun::domain(com_mod, lM, cEq, e);</div>
<div class="line">  <span class="keyword">auto</span> cPhys = com_mod.<a class="code" href="class_com_mod.html#aba060eb3db7bc3bcafc86374fc5ce2e2">eq</a>[cEq].dmn[iDmn].phys;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> a = 0; a &lt; lM.<a class="code" href="classmsh_type.html#a7650e323d00e7041a99014f03c36242b">eNoN</a>; a++) {</div>
<div class="line">    <span class="keywordtype">int</span> Ac = lM.<a class="code" href="classmsh_type.html#af675d03d8fbfe19bbf7e1cdd2a6db639">IEN</a>(a,e);</div>
<div class="line">    xl.set_col(a, com_mod.<a class="code" href="class_com_mod.html#a1f6e06247d04da6550fb03731ef3a024">x</a>.col(Ac));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (com_mod.<a class="code" href="class_com_mod.html#ad9422942752e5ac626926b60ab3ea40d">mvMsh</a>) {</div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nsd; i++) {</div>
<div class="line">        dol(i,a) = com_mod.<a class="code" href="class_com_mod.html#abe59a1b34b4ad737800637b511c41fa7">Do</a>(i + nsd + 1, Ac);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (com_mod.<a class="code" href="class_com_mod.html#ad9422942752e5ac626926b60ab3ea40d">mvMsh</a>) {</div>
<div class="line">    xl = xl + dol;</div>
<div class="line">  }</div>
<div class="ttc" id="aclass_com_mod_html_a1f6e06247d04da6550fb03731ef3a024"><div class="ttname"><a href="class_com_mod.html#a1f6e06247d04da6550fb03731ef3a024">ComMod::x</a></div><div class="ttdeci">Array&lt; double &gt; x</div><div class="ttdoc">Position vector of mesh nodes (in ref config)</div><div class="ttdef"><b>Definition:</b> ComMod.h:1524</div></div>
<div class="ttc" id="aclass_com_mod_html_aba060eb3db7bc3bcafc86374fc5ce2e2"><div class="ttname"><a href="class_com_mod.html#aba060eb3db7bc3bcafc86374fc5ce2e2">ComMod::eq</a></div><div class="ttdeci">std::vector&lt; eqType &gt; eq</div><div class="ttdoc">All data related to equations are stored in this container.</div><div class="ttdef"><b>Definition:</b> ComMod.h:1570</div></div>
<div class="ttc" id="aclass_com_mod_html_abe59a1b34b4ad737800637b511c41fa7"><div class="ttname"><a href="class_com_mod.html#abe59a1b34b4ad737800637b511c41fa7">ComMod::Do</a></div><div class="ttdeci">Array&lt; double &gt; Do</div><div class="ttdoc">Old integrated variables (dissplacement)</div><div class="ttdef"><b>Definition:</b> ComMod.h:1512</div></div>
<div class="ttc" id="aclass_com_mod_html_ad9422942752e5ac626926b60ab3ea40d"><div class="ttname"><a href="class_com_mod.html#ad9422942752e5ac626926b60ab3ea40d">ComMod::mvMsh</a></div><div class="ttdeci">bool mvMsh</div><div class="ttdoc">Whether mesh is moving.</div><div class="ttdef"><b>Definition:</b> ComMod.h:1322</div></div>
<div class="ttc" id="aclassmsh_type_html_a7650e323d00e7041a99014f03c36242b"><div class="ttname"><a href="classmsh_type.html#a7650e323d00e7041a99014f03c36242b">mshType::eNoN</a></div><div class="ttdeci">int eNoN</div><div class="ttdoc">Number of nodes (control points) in a single element.</div><div class="ttdef"><b>Definition:</b> ComMod.h:825</div></div>
<div class="ttc" id="aclassmsh_type_html_adaaafdbbe89881032d38cd699aed1031"><div class="ttname"><a href="classmsh_type.html#adaaafdbbe89881032d38cd699aed1031">mshType::nEl</a></div><div class="ttdeci">int nEl</div><div class="ttdoc">Number of elements (knot spans)</div><div class="ttdef"><b>Definition:</b> ComMod.h:837</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Namespaces</h2>
<p>Refer to the elements in the std namespace by explicit qualification using std::. </p><div class="fragment"><div class="line">std::cout &lt;&lt; &quot;Use std namespace.&quot; &lt;&lt; std::endl;</div>
<div class="line">std::string file_name;</div>
<div class="line">std::vector&lt;int&gt; outS(nOut+1);</div>
</div><!-- fragment --><p>It is acceptable to use unqualified names for svFSIplus namespaces </p><div class="fragment"><div class="line">using namespace consts;</div>
<div class="line">double dmp = dmn.prop.at(PhysicalProperyType::damping);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Naming Conventions</h2>
<p>Program readability is improved by using names that would be clear to any developer.</p>
<ul>
<li>Use names that describe purpose or intent</li>
<li>There's no reason to be terse when naming things. It is more important to make code immediately understandable by a new reader</li>
<li>Minimize the use of specialized abbreviations (e.g., those from a paper or text book) that may in general be unfamiliar to other developers</li>
<li>Do not abbreviate names especially for class methods/data members<ul>
<li><b>command</b> instead of <b>cmd</b></li>
<li><b>initialize</b> instead of <b>init</b></li>
<li><b>compute_average()</b> instead of <b>comp_avg()</b></li>
</ul>
</li>
<li>Local names may be abbreviated for local variables when context is clear<ul>
<li><b>num_points</b> is OK instead of <b>number_of_points</b></li>
</ul>
</li>
<li>Variables with a large scope should have long names, variables with a small scope may have short names</li>
<li>Names for boolean variables and methods should be obviously boolean<ul>
<li>use <b>is_valid</b> instead of <b>flag</b></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
Styles</h2>
<p>Two naming styles are used svFSIplus</p>
<ul>
<li>CamelCase</li>
<li>snake_case</li>
</ul>
<p>CamelCase is a way to separate the words in a phrase by making the first letter of each word capitalized and not using spaces.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
File Names</h2>
<p>C++ files should end in .cpp and header files should end in .h.</p>
<p>Files that contain a single class should have the name of the class, including capitalization.</p><ul>
<li>MyClass.h, MyClass.cc</li>
</ul>
<h2><a class="anchor" id="autotoc_md38"></a>
Type Names</h2>
<p>Type names are in CamelCase.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="class_simulation.html">Simulation</a> { }</div>
<div class="line"><a class="code" href="class_cep_mod.html">CepMod</a> cep_mod;</div>
<div class="ttc" id="aclass_simulation_html"><div class="ttname"><a href="class_simulation.html">Simulation</a></div><div class="ttdef"><b>Definition:</b> Simulation.h:41</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
Variable and Functions Names</h2>
<p>Variable and function names use snake_case. </p><div class="fragment"><div class="line">std::string history_file_name;</div>
<div class="line"><span class="keywordtype">void</span> b_ustruct_3d(<span class="keyword">const</span> <a class="code" href="class_com_mod.html">ComMod</a>&amp; com_mod);</div>
</div><!-- fragment --><p> Data members of classes additionally have trailing underscores.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Comments</h2>
<p>Comments are absolutely vital to keeping code readable. While comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments.</p>
<p>Don't literally describe what code does unless the behavior is nonobvious to a reader who understands C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing.</p>
<p>Comments should be included relative to their position in the code </p><div class="fragment"><div class="line"><span class="comment">// yes</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="comment">// Do something</span></div>
<div class="line">    something();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// no</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line"><span class="comment">// Do something now</span></div>
<div class="line">    something();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md41"></a>
File Comments</h2>
<p>Start each file with license boilerplate. Every file should contain license boilerplate.</p>
<p>File comments describe the contents of a file. A .h file will contain comments describing any classes defined there. A .cpp file will contain comments describing the purpose of the functions or class methods defined there.</p>
<p>Do not duplicate comments in both the .h and the .cpp files.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
Class Comments</h2>
<p>Every non-obvious class or struct declaration should have an accompanying comment that describes what it is for and how it should be used.</p>
<p>Comments describing the use of the class should go together with its interface definition; comments about the class operation and implementation should accompany the implementation of the class's methods.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Function Comments</h2>
<p>Every function declaration should have comments immediately preceding it that describe what the function does and how to use it. If there is anything tricky about how a function does its job, the function definition should have an explanatory comment.</p>
<p>The function implementation should have comments describing tricky, non-obvious, interesting, or important parts of the code.</p>
<p>Function comments should follow Doxygen format for API functions.</p>
<p>Non API functions should have the form </p><div class="fragment"><div class="line">Parameters</div>
<div class="line">  param1[in] Description</div>
<div class="line">  param1[out] Description</div>
<div class="line"> </div>
<div class="line">Returns</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md44"></a>
Variables</h2>
<p>Variables should be initialized where they are declared when possible. This ensures that variables are valid at any time. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> average{0.0};</div>
<div class="line"><span class="keywordtype">int</span> num_points = 0;</div>
</div><!-- fragment --><p>Variables must never have dual meaning. This ensures that all concepts are represented uniquely.</p>
<p>Global variable use should be minimized. In C++ there is no reason that global variables need to be used at all.</p>
<p>Variables should be declared in the smallest scope possible. By keeping the operations on a variable within a small scope it is easier to control the effects and side effects of the variable.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
General Programming</h2>
<p>Use nullptr instead of 0 and NULL.</p>
<p>Use const rather than #define statements. </p><div class="fragment"><div class="line"><span class="comment">// Replace </span></div>
<div class="line"><span class="preprocessor">#define A_POWER_OF_TWO 16</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// with</span></div>
<div class="line"><span class="keywordtype">int</span> <span class="keyword">const</span> A_POWER_OF_TWO = 16;</div>
</div><!-- fragment --><p>Avoid deeply nested code. Code that is too deeply nested is hard to both read and debug. One should replace excessive nesting with function calls.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Coding Guidelines</h1>
<p>This section describes the coding guidelines that are recommend when adding new code to svFSIplus.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Enums</h2>
<p>Where possible, put enums in appropriate classes </p><div class="fragment"><div class="line"><span class="keyword">class </span>Grade {</div>
<div class="line">    <span class="keyword">enum</span> { HIGH, MIDDLE, LOW };</div>
<div class="line"> </div>
<div class="line">    Grade() {}</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md48"></a>
Type Conversions</h2>
<p>Type conversions should be avoided if possible.</p>
<p>When required, type conversions must always be done explicitly using C++ style casts. Never rely on implicit type conversion.</p>
<div class="fragment"><div class="line">double r = static_cast&lt;double&gt;(i) / 3.0;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
Function Parameters</h2>
<p>Arguments that are non-primitive types and will not be modified should be passed by const reference. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> calc_elem_ar(<span class="keyword">const</span> <a class="code" href="class_com_mod.html">ComMod</a>&amp; com_mod, <span class="keyword">const</span> <a class="code" href="class_cm_mod.html">CmMod</a>&amp; cm_mod, <a class="code" href="classmsh_type.html">mshType</a>&amp; lM, <span class="keywordtype">bool</span>&amp; rflag)</div>
<div class="ttc" id="aclass_cm_mod_html"><div class="ttname"><a href="class_cm_mod.html">CmMod</a></div><div class="ttdoc">The CmMod class duplicates the data structures in the Fortran CMMOD module defined in COMU....</div><div class="ttdef"><b>Definition:</b> CmMod.h:62</div></div>
</div><!-- fragment --><p>Output parameters should grouped at the end of the function's parameters. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
