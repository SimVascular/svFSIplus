<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>svFSIplus: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">svFSIplus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>svFSI_cinterface </h1>
<p>This directory contains the C++ solver implementation. The C++ code attempts to replicate the data structures and flow of control of the Fortran implementation.</p>
<p>The <code><a class="el" href="class_simulation.html">Simulation</a></code> class stores solver parameters and data, and has methods to read solver parameters from a XML file and create mesh data (e.g. nodes and element connectivity) from VTK .vtu and .vtp files. A <code><a class="el" href="class_simulation.html">Simulation</a></code> object can be created and stored in the the Fortran <code>CMMOD</code> module. It can then be called to replicated the Fortran flow of control and compare data created by C++ and Fortran.</p>
<h1>Reading the solver parameter input XML file </h1>
<p>The <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> class is used to read and store solver parameters from an XML file. The XML file organization and parameter names replicate the old input text file except that parameter names have spaces replaced by underscores.</p>
<h1>Calling C++ from Fortran </h1>
<p>The <code>simulation_wrap.h,.cpp</code> files provide an interface used to call C++ functions from Fortran. Data created in the C++ code can be returned to the Fortran code for comparison.</p>
<p>The following interface functions are defiined</p>
<ul>
<li>create_simulation() - Creates and returns a <a class="el" href="class_simulation.html">Simulation</a> object.</li>
<li>get_mesh_data() - Returns mesh data for a specific mesh name.</li>
<li>read_files() - Reads in the solver parameter input XML file and creates all mesh data.</li>
</ul>
<h1>C++ organizatiion to replicate Fortran </h1>
<p>Most of the Fortran code is replicated in C++ using the same file and subroutine names converted to lower case with underscores. For example</p>
<div class="fragment"><div class="line">================================================================================================</div>
<div class="line">             Fortran                       |                      C++ </div>
<div class="line">================================================================================================</div>
<div class="line">        SUBROUTINE READFILES               |                  read_files()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">        SUBROUTINE READMSH                 |                  read_msh()</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            LOADMSH.f                      |                  load_msh.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
<div class="line">            VTKXML.f                       |                  vtk_xml.cpp</div>
<div class="line">------------------------------------------------------------------------------------------------</div>
</div><!-- fragment --><p>All Fortan subroutines located in a particular file will typically have a C++ implementation in a similarly named file.</p>
<p>C++ functions are defined within a <code>namespace</code> defined for each Fortran file. For example, the functioins in <code>load_msh.cpp</code> are defined within the <code>load_msh</code> <code>namespace</code>. Some <code>namespaces</code> are named with a <code>_ns</code> suffix to prevent conflicts with function names (e.g. <code><a class="el" href="namespaceread__files__ns.html" title="Define some types used to pass data to functions.">read_files_ns</a></code>).</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Fortran Modules</h1>
<p>C++ classes are used to implement Fortran modules. Fortran variable names are retained to prevent (or maintain) confusion. There are no global variables. Modules are accessed from a <code><a class="el" href="class_simulation.html">Simulation</a></code> object.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
CmMod</h2>
<p>The <code><a class="el" href="class_cm_mod.html" title="The CmMod class duplicates the data structures in the Fortran CMMOD module defined in COMU....">CmMod</a></code> class implements the <code>CMMOD</code> module defined in <code>COMU.f</code>. This is used for MPI communication.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
ComMod</h2>
<p>The <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> class implments the <code>COMOD</code> module defiined in <code>MOD.f</code>.</p>
<p>All solver data is stored in the <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> class using the same names used in the <code>COMOD</code> module.</p>
<h1 id="flow_of_control">Flow of control </h1>
<p>The following outlines the code flow of control for simulations.</p>
<ul>
<li><a href="#program_main">PROGRAM MAIN</a><ul>
<li><a href="#function_create_simulation">sim_interface = simulation()</a></li>
<li><a href="#subroutine_read_files">call sim_interface % read_files(in_file_name)</a><ul>
<li><a href="#read_files_c">call read_files_c(this % Simulation_object, c_file_name)</a><ul>
<li><a href="#read_files_ns_read_files"><em>read_files_ns::</em><b>read_files(simulation, std::string(file_name))</b></a><ul>
<li><a href="#simulation_read_parameters">simulation-&gt;<b>read_parameters()</b></a> - Read solver parameter XML file</li>
<li><a href="#simulation_set_module_parameters">simulation-&gt;<b>set_module_parameters()</b></a> - Set <a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a> module varliables</li>
<li><a href="#read_msh_ns_read_msh"><em>read_msh_ns::</em><b>read_msh(simulation)</b></a> - Read all mesh and BCs data<ul>
<li><a href="#load_msh_read_sv"><em>load_msh::</em><b>read_sv(param, mesh)</b></a> - Read mesh nodal coordinates and element connectivity<ul>
<li><a href="#read_vtu"><em>vtk_xml::</em><b>read_vtu(mesh_path, mesh)</b></a> - Read a mesh from a SimVascular .vtu file<ul>
<li><a href="#vtk_xml_parser_load_vtk"><em>vtk_xml_parser::</em><b>load_vtu(file_name, mesh)</b></a> - Read a mesh from a .vtu file and store its data into mesh</li>
</ul>
</li>
<li><a href="#nn_select_ele"><em>nn::</em><b>select_ele(simulation, mesh)</b></a> - Set mesh variables for the input element type<ul>
<li><a href="#set_3d_element_props"><b>set_3d_element_props[mesh.eNoN](mesh)</b></a> - Set element properties based on the number of element nodes</li>
<li><a href="#get_gip_mesh"><b>get_gip(simulation, mesh)</b></a> - Set mesh w and xi arrays used for Gauss integration</li>
<li><a href="#get_gnn_mesh"><b>get_gnn(simulation, g, mesh)</b></a> - Create mesh N and Nx shape function arrays for each Gaus point g</li>
<li><a href="#get_nn_bnds_mesh"><b>get_nn_bnds(simulation, mesh)</b></a> - Create bounds on Gauss integration points and shape functions</li>
</ul>
</li>
<li><a href="#read_msh_ns_check_ien"><em>read_msh_ns::</em><b>check_ien(simulation, mesh)</b></a> - Check/change the mesh connectivity and node ordering<ul>
<li><a href="#check_element_conn"><b>check_element_conn[eType](mesh)</b></a></li>
</ul>
</li>
<li><a href="#vtk_xml_read_vtp"><em>vtk_xml::</em><b>read_vtp(face_path, face)</b></a> - Read a face nodal coordinates and element connectivity from a .vtp file<ul>
<li><a href="#vtk_xml_parser_load_vtp"><em>vtk_xml_parser::</em><b>load_vtp(file_name, face)</b></a> - Store data read from a .vtp file into a <a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a> object</li>
</ul>
</li>
<li><a href="#nn_select_eleb"><em>nn::</em><b>select_eleb(simulation, mesh, face)</b></a> - Set face properties for the input element type<ul>
<li><a href="#set_face_element_props"><b>set_face_element_props[face.eNoN](insd, face)</b></a></li>
<li><a href="#get_gip_face"><b>get_gip(simulation, face)</b></a></li>
<li><a href="#get_gnn_face"><b>get_gnn(simulation, g, face)</b></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#set_projector"><b>set_projector(simulation, avNds)</b></a> - Process projection faces<ul>
<li><a href="#find_face"><b>all_fun::find_face(com_mod.msh, ctmpi, iM, iFa)</b></a> - Process projection faces</li>
<li><a href="#match_faces"><b>match_faces(com_mod, face1, face2, tol, lPrj)</b></a> - Process projection faces<ul>
<li><a href="#find_blk"><b>find_blk(nsd, nBkd, nFlt, xMin, dx, coord)</b></a> - Compute the block ID for the given coordinate</li>
</ul>
</li>
</ul>
</li>
<li><a href="#read_fib_nff"><b>read_fib_nff(simulation, com_mod.msh[iM], cTmp, "FIB_DIR", i)</b></a> - Read fiber orientation<ul>
<li><a href="#load_fiber_direction_vtu"><b>vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)</b></a> - Read fiber orientation from vtu</li>
</ul>
</li>
<li><a href="#read_vtu_pdata"><b>vtk_xml::read_vtu_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, 0, com_mod.msh[iM])</b></a> - Read prestress data</li>
<li><a href="#load_var_ini"><b>load_var_ini(simulation, com_mod)</b></a> - Set initial mesh pressure, velocity or displacement from a file</li>
<li><b>Read contact model parameters (not implmented, no tests)</b></li>
</ul>
</li>
<li><a href="#read_eq"><b>read_eq(simulation, simulation, eq_params, eq)</b></a> - Iterate to read equations<ul>
<li><a href="#set_equation_properties"><b>set_equation_properties(simulation, eq_params, lEq, propL, outPuts, nDOP)</b></a> - Set equation properties<ul>
<li><a href="#set_equation_props"><b>set_equation_props[eq_type](simulation, eq_params, lEq, propL, outPuts, nDOP)</b></a> - Set equation properties (function map)</li>
</ul>
</li>
<li><a href="#read_outputs"><b>read_outputs(simulation, eq_params, lEq, nDOP, outPuts)</b></a> - Set output parameters</li>
<li><a href="#read_bc"><b>read_bc(simulation, Set output parameters)</b></a> - Iterate to read boundary conditions<ul>
<li><a href="#read_trac_bcff"><b>read_trac_bcff(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)</b></a> - Read traction data</li>
<li><a href="#read_temporal_values_file"><b>read_temporal_values_file(file_name, lBc)</b></a> - Set boundary condition temporal values read in from a file</li>
<li><a href="#read_fourier_coeff_values_file"><b>read_fourier_coeff_values_file(file_name, lBc)</b></a> - Set boundary condition Fourier coefficients read in from a file</li>
<li><a href="#read_bct"><b>read_bct(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)</b></a> - Reads general velocity data from bct.vtp</li>
<li><a href="#read_temporal_and_spatial_values_file"><b>read_temporal_and_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)</b></a> - Read in a file containing temporal and spatial values</li>
<li><a href="#read_spatial_values_file"><b>read_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)</b></a> - Read in a file containing spatial values</li>
<li><a href="#read_vtp_pdata"><b>vtk_xml::read_vtp_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, data_series, face)</b></a> - Read prestress tensor for CMM</li>
<li><a href="#read_vtp_pdata"><b>vtk_xml::read_vtp_pdata(cTmp, "Displacement", com_mod.nsd, com_mod.nsd, data_series, face)</b></a> - Read displacement for CMM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#subroutine_distribute_data"><b>call sim_interface % distribute_data()</b></a><ul>
<li><a href="#distribute_data"><b>call distribute_data_c(this % Simulation_object)</b></a><ul>
<li><a href="#distribute"><b>distribute(Simulation* simulation))</b></a> - Partition and distribute data across processors<ul>
<li><a href="#bcast"><b>cm.bcast(cm_mod, &amp;chnl_mod.pClr)</b></a> -</li>
<li><a href="#bcast"><b>cm.bcast(cm_mod, chnl_mod.appPath)</b></a> -</li>
<li><a href="#bcast"><b>cm.bcast(cm_mod, &amp;com_mod.nMsh)</b></a> -</li>
<li><a href="#bcast"><b>cm.bcast(cm_mod, &amp;com_mod.nsd)</b></a> -</li>
<li><a href="#bcast"><b>cm.bcast(cm_mod, wrk)</b></a> -</li>
<li><a href="#split_jobs"><em>all_fun::</em><b>split_jobs(task_id, nMsh, num_proc, wgt, wrk)</b></a> - Spliting "m" jobs between "n" workers</li>
<li><a href="#part_msh"><b>part_msh(simulation, com_mod.msh[iM], gmtl, num_proc, iWgt)</b></a> - Partition each mesh iM<ul>
<li><a href="#select_ele"><em>nn::</em><b>select_ele(simulation, lM)</b></a> - Spliting "m" jobs between "n" workers</li>
<li><a href="#split_"><b>split_(&amp;nEl, &amp;eNoN, &amp;eNoNb, lM.IEN.data_, &amp;num_proc, lM.eDist.data_, wgt.data_, part.data_)</b></a> - Partitioning using ParMetis</li>
</ul>
</li>
<li><a href="#part_face"><b>part_face(simulation, msh, face, tMs[iM].fa[iFa], gmtl)</b></a> - Partitioning iFa faces for each mesh iM <br  />
<ul>
<li><a href="#select_eleb"><em>nn::</em><b>select_eleb(simulation, lM, gFa)</b></a> - Set face properties for the input element type</li>
</ul>
</li>
<li><a href="#local_rv"><em>all_fun::</em><b>local_rv(com_mod, cm_mod, cm, tmpX)</b></a> - Send a real vector to all the processors</li>
<li><a href="#dist_eq"><b>dist_eq(com_mod, cm_mod, cm, tMs, gmtl, cep_mod, com_mod.eq[iEq])</b></a> - Distribute equation iEq to processors<ul>
<li><a href="#dist_mat_consts"><b>dist_mat_consts(com_mod, cm_mod, cm, dmn.stM)</b></a> - Distribute material properties to processors</li>
<li><a href="#dist_bc"><b>dist_bc(com_mod, cm_mod, cm, lEq.bc[iBc], tMs, gmtl)</b></a> - Distribute boundary condition data to processors</li>
<li><a href="#dist_visc_model"><b>dist_visc_model(com_mod, cm_mod, cm, dmn.visc)</b></a> - Distribute viscosity model to processors</li>
<li><a href="#dist_bf"><b>dist_bf(com_mod, cm_mod, cm, lEq.bf[iBf])</b></a> - Distribute boundary fource to processors</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#subroutine_initialize_solution"><b>call sim_interface % initialize_solution(timeP)</b></a><ul>
<li><a href="#initialize_solution_c"><b>call initialize_solution_c(this % Simulation_object, timeP)</b></a><ul>
<li><a href="#initialize_solution"><b>initialize_solution(Simulation* simulation)</b></a> - Initialize or finalize svFSI variables/structures<ul>
<li><a href="#ten_init"><b>mat_fun::ten_init(nsd)</b></a> - Initialize tensor operations</li>
<li><a href="#lhsa"><b>lhsa_ns::lhsa(simulation, nnz)</b></a> - Constructing stiffness matrix</li>
<li><a href="#fsils_commu_create"><b>fsi_linear_solver::fsils_commu_create(communicator, cm.com())</b></a> -</li>
<li><a href="#fsils_lhs_create"><b>fsi_linear_solver::fsils_lhs_create(com_mod.lhs, communicator, com_mod.gtnNo, com_mod.tnNo, nnz,com_mod.ltg, com_mod.rowPtr, com_mod.colPtr, nFacesLS)</b></a> - Initialize FSILS structures</li>
<li><a href="#cep_init"><b>cep_ion::cep_init(simulation)</b></a> -<ul>
<li><a href="#cep_init_l"><b>cep_ion::cep_init_l(CepMod&amp; cep_mod, cepModelType&amp; cep, int nX, int nG, Vector&lt;double&gt;&amp; X, Vector&lt;double&gt;&amp; Xg)</b></a> -<ul>
<li>[<b>cep_mod.ap.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.bo.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.bfn.init(nX, X)</b>]() -</li>
<li>[<b>cep_mod.ttp.init(cep.imyo, nX, nG, X, Xg)</b>]() -</li>
</ul>
</li>
</ul>
</li>
<li><a href="#init_fs_msh"><b>fs::init_fs_msh(com_mod, mesh)</b></a> -</li>
<li><a href="#init_fs_face"><b>fs::init_fs_face(com_mod, mesh, mesh.fa[iFa])</b></a> -</li>
<li><a href="#integ"><b>all_fun::integ(com_mod, cm_mod, i, s, 0, 0)</b></a> - Calculating the volume of each domain</li>
<li><a href="#baf_ini"><b>baf_ini_ns::baf_ini(simulation)</b></a> - Preparing faces<ul>
<li><a href="#"><b>set_bc::rcr_init(com_mod, cm_mod)</b></a></li>
<li><a href="#"><b>set_bc::genBC_Integ_X(com_mod, cm_mod, "I")</b></a></li>
<li><a href="#"><b>set_bc::calc_der_cpl_bc(com_mod, cm_mod)</b></a></li>
<li><a href="#fsi_ls_ini"><b>fsi_ls_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], lsPtr)</b></a></li>
<li><a href="#fsils_bc_create"><b>fsils_bc_create(com_mod.lhs, lsPtr, i, nsd, BcType::BC_TYPE_Dir, gNodes)</b></a></li>
</ul>
</li>
<li><a href="#set_bc_dir"><b>set_bc::set_bc_dir(com_mod, com_mod.Ao, com_mod.Yo, com_mod.Do)</b></a> - Preparing BCs<ul>
<li><a href="#set_bc_dir_l"><b>set_bc::set_bc_dir_l(com_mod, bc, com_mod.msh[iM].fa[iFa], tmpA, tmpY, lDof)</b></a></li>
</ul>
</li>
<li>[<b>txt_ns::txt(simulation, true)</b>]() -</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#subroutine_iterate_solution"><b>call sim_interface % iterate_solution()</b></a><ul>
<li><a href="#iterate_solution"><b>call interate_solution_c(this % Simulation_object)</b></a><ul>
<li><a href="#picp"><b> pic::picp(simulation) </b></a> - Predictor<ul>
<li><a href="#cep_integ"><b> cep_ion::cep_integ(simulation, iEq, e, Do) </b></a></li>
</ul>
</li>
<li><a href="#set_bc_dir"><b> set_bc::set_bc_dir(com_mod, An, Yn, Dn) </b></a> - Apply Dirichlet BCs strongly</li>
<li><b> Inner Loop </b><ul>
<li><a href="#set_bc_cpl"><b> set_bc::set_bc_cpl(com_mod, cm_mod) </b></a> - If com_mod.cplBC.coupled</li>
<li><a href="#set_bc_dir"><b> set_bc::set_bc_dir(com_mod, An, Yn, Dn) </b></a> - If com_mod.cplBC.coupled</li>
<li><a href="#pici"><b> pic::pici(simulation, Ag, Yg, Dg) </b></a> - Initiator step</li>
<li><a href="#ls_alloc"><b> ls_ns::ls_alloc(com_mod, eq) </b></a></li>
<li><a href="#set_bf"><b> bf::set_bf(com_mod, Dg) </b></a><ul>
<li><a href="#set_bf_l"><b> bf::set_bf_l(com_mod, eq.bf[iBf], com_mod.msh[iM], Dg) </b></a><ul>
<li><a href="#"><b> ifft(com_mod, lBf.bt, f, rtmp) </b></a> - If bfType_ustd</li>
<li><a href="#"><b> igbc(com_mod, lBf.bm, bfl, xl) </b></a> - If bfType_gen</li>
<li><a href="#bf_construct"><b> bf::bf_construct(com_mod, lM, e, eNoN, idof, xl, dl, bfl, ptr) </b></a> - For shell follower pressre loads or init pressure for CMM</li>
</ul>
</li>
</ul>
</li>
<li><a href="#global_eq_assem"><b> eq_assem::global_eq_assem(com_mod, com_mod.msh[iM], Ag, Yg, Dg) </b></a> - For each mesh iM<ul>
<li><a href="#construct_fluid"><b> fluid::construct_fluid(com_mod, lM, Ag, Yg) </b></a> - If EquationType::phys_fluid<ul>
<li><a href="#"><b> fs::get_thood_fs(com_mod, fs, lM, vmsStab, 1) </b></a></li>
<li><a href="#"><b> nn::gnn(fs[1].eNoN, nsd, nsd, Nx, xql, Nqx, Jac, ksix) </b></a></li>
<li><a href="#"><b> nn::gn_nxx(l, fs[0].eNoN, nsd, nsd, Nx, Nxx, xwl, Nwx, Nwxx) </b></a></li>
<li><a href="#"><b> fluid_3d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK)</b></a> - If nsd=3</li>
<li><a href="#"><b> fluid_2d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK)</b></a> - If nsd=2</li>
<li><a href="#"><b> trilinos_doassem_(const_cast&lt;int&amp;&gt;(eNoN), ptr.data(), lK.data(), lR.data())</b></a> - If using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
<li><a href="#do_assem"><b> lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)</b></a> - If not using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#set_bc_neu"><b> set_bc::set_bc_neu(com_mod, cm_mod, Yg, Dg) </b></a></li>
<li><a href="#set_bc_cmm"><b> set_bc::set_bc_cmm(com_mod, cm_mod, Ag, Dg) </b></a></li>
<li><a href="#"><b> set_bc::set_bc_dir_w(com_mod, Yg, Dg) </b></a></li>
<li><a href="#"><b> contact::contact_forces(com_mod, cm_mod, Dg) </b></a></li>
<li><a href="#"><b> all_fun::commu(com_mod, com_mod.R) </b></a> - Synchronize residual R across processes</li>
<li><a href="#"><b> ustruct::ustruct_r(com_mod, Yg) </b></a></li>
<li><a href="#"><b> fs::thood_val_rc(com_mod) </b></a></li>
<li><a href="#"><b> set_bc::set_bc_undef_neu(com_mod) </b></a></li>
<li><a href="#"><b> ls_ns::ls_solve(com_mod, eq, incL, res) </b></a></li>
<li><a href="#"><b> pic::picc(simulation) </b></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="fortran_implementation_details">Fortran Implementation </h1>
<p>The following sections provide some implementation details of the Fortran/C++ interface.</p>
<h2 id="program_main">PROGRAM MAIN </h2>
<p>Fortran main program defined in <code>MAIN.f</code>.</p>
<ul>
<li><code>sim_interface = simulation()</code> - Create a C++ <code><a class="el" href="class_simulation.html">Simulation</a></code> object, calls <code>create_simulation()</code> function.</li>
<li><code>call sim_interface % read_files(in_file_name)</code> - Read solver parameters from a solver input XML file and create all of the mesh data.</li>
</ul>
<h2 id="function_create_simulation">function create_simulation() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function to create a <code><a class="el" href="class_simulation.html">Simulation</a></code> object.</p>
<ul>
<li><code>create_simulation % Simulation_object = create_simulation_c()</code> - Calls C++ <code>create_simulation</code> functon.</li>
</ul>
<h2 id="create_simulation">Simulation* create_simulation() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to create a C++ <code><a class="el" href="class_simulation.html">Simulation</a></code> object and return it to Fortran.</p>
<ul>
<li><code>Simulation::Simulation()</code>- Create a C++ <a class="el" href="class_simulation.html">Simulation</a> object<ul>
<li>Create <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> member, set defaults in ctor</li>
<li>Create <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> member</li>
</ul>
</li>
</ul>
<h2 id="subroutine_read_files">subroutine read_files(this, file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>read_files()</code> function.</p>
<ul>
<li><code>call read_files_c(this % Simulation_object, c_file_name)</code> - Call C++ <code>read_files</code> functon.</li>
</ul>
<h2 id="subroutine_distribute_data">subroutine distribute_data(this) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>()</code> function.</p>
<ul>
<li><code>call distribute_data_c(this % Simulation_object)</code></li>
</ul>
<h2 id="subroutine_initialize_solution">subroutine initialize_solution(this, timep) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<p>Fortran / C++ interface function used to call the C++ <code>()</code> function.</p>
<ul>
<li><code>call initialize_solution_c(this % Simulation_object, timep_cptr)</code></li>
</ul>
<h2 id="subroutine_iterate_solution">subroutine iterate_solution(this) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI/simulation_interface_mod.f90">simulation_interface_mod.f90</a></p>
<ul>
<li><code>call iterate_solution_c(this % Simulation_object)</code></li>
</ul>
<h1 id="cpp_implementation_details">C++ Implementation </h1>
<p>The following sections provide some implementation details of the C++ code replicating Fortran functionality.</p>
<h2 id="read_files_c">void read_files(Simulation* simulation, const char* file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to read in an XML file and all mesh and BC data.</p>
<ul>
<li><code>read_files_ns::read_files(simulation, std::string(file_name))</code></li>
</ul>
<h2 id="read_files_ns_read_files">void read_files_ns::read_files(Simulation* simulation, const std::string&amp; file_name) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Read in an XML file and, all mesh and BC data. Replicates <code>SUBROUTINE READFILES</code> in <code>READFILES.f</code></p>
<ul>
<li><code><a class="el" href="class_simulation.html#aade1883dedf6e7145283f3a09fd22b7d" title="Read solver parameters.">Simulation::read_parameters()</a></code> - Read solver parameter XML file</li>
<li><code>Simulation::set_parameters()</code> - Set module (e.g.<code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code>) and <code><a class="el" href="class_simulation.html">Simulation</a></code> member data from <code><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a></code> data</li>
<li><code>read_msh_ns::read_msh(simulation)</code> - Read mesh and BCs data</li>
</ul>
<h2 id="simulation_read_parameters">void <a class="el" href="class_simulation.html#aade1883dedf6e7145283f3a09fd22b7d" title="Read solver parameters.">Simulation::read_parameters(const std::string&amp; file_name)</a> </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/Simulation.cpp">Simulation.cpp</a></p>
<p>Read solver parameter XML file.</p>
<ul>
<li><code>parameters_.read_parameters(file_name)</code></li>
</ul>
<h2 id="simulation_set_module_parameters">void <a class="el" href="class_simulation.html#a11f808780839667a1055ae513ea1af51" title="Set the simulation and module member data.">Simulation::set_module_parameters()</a> </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/Simulation.cpp">Simulation.cpp</a></p>
<p>Set <code><a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a></code> module varliables.</p>
<h2 id="read_msh_ns_read_msh">void read_msh_ns::read_msh() </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Read all mesh and BCs data. Replicates <code>SUBROUTINE READMSH</code> in <code>READMSH.f</code></p>
<ul>
<li>Set the number of meshes<code>com_mod.nMsh</code></li>
<li>Allocate <code>com_mod.msh</code> storing a list of <code><a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a></code> objects</li>
<li>Iterate over each <code>mesh</code> in <code>com_mod.msh</code> defined by each <code>Add_mesh</code> parameter in the XML file with parameter values in <code>param</code><ul>
<li><code>load_msh::read_sv(param, mesh)</code> - Read in a volume meshes and face meshes from a VTK files</li>
<li><code>read_msh_ns::check_ien(simulation, mesh)</code> - Check the mesh element node ordering and change element node ordering if needed</li>
</ul>
</li>
<li>Re-arranging x and finding the size of the entire domain</li>
<li>Renumber face node IDs</li>
<li><code>read_fib_nff(simulation, com_mod.msh[iM], cTmp, "FIB_DIR", i)</code> - Read fiber orientation<ul>
<li><code>vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)</code></li>
</ul>
</li>
<li>Iterate over each <code>mesh</code> iM in <code>com_mod.msh</code> to set read prestress data<ul>
<li>vtk_xml::read_vtu_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, 0, com_mod.msh[iM]) - Read prestress data</li>
</ul>
</li>
<li>If have prestress data then set com_mod.pS0()</li>
<li>Set initial mesh pressure, velocity or displacement from a file<ul>
<li><code>load_var_ini(simulation, com_mod)</code></li>
</ul>
</li>
</ul>
<h2 id="load_msh_read_sv">void load_msh::read_sv(Simulation* simulation, mshType&amp; mesh, const MeshParameters&amp; param) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/load_msh.cpp">load_mesh.cpp</a></p>
<p>Read mesh nodal coordinates and element connectivity. Replicates <code>SUBROUTINE READSV(list, lM)</code> in <code>LOADMSH.f</code>.</p>
<ul>
<li><code>vtk_xml::read_vtu(mesh_path, mesh)</code> - Read in volume mesh</li>
<li><code>nn::select_ele(simulation, mesh)</code> - Set mesh element properites for the input element type</li>
</ul>
<h2 id="read_vtu">void read_vtu(const std::string&amp; file_name, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">vtk_xml.cpp</a></p>
<p>Read a mesh from a SimVascular <code>.vtu</code> file. Replicates Fortran <code>SUBROUTINE READVTU(lM, fName)</code> defined in <code>VTKXML.f</code>.</p>
<ul>
<li><code>vtk_xml_parser::load_vtk(VtkFileFormat::VTU, file_name, mesh)</code> - Read a VTK <code>.vtu</code> file and store its data into <code>mesh</code>.</li>
</ul>
<h2 id="vtk_xml_parser_load_vtk">void vtk_xml_parser::load_vtu(const std::string&amp; file_name, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">vtk_xml_parser.cpp</a></p>
<p>Read a mesh from a <code>.vtu</code> file and store its data into <code>mesh</code>. This calls VTK functions.</p>
<p>Replicates </p><div class="fragment"><div class="line">subroutine loadVTK(vtk,fName,istat)</div>
<div class="line">subroutine getVTK_numPoints(vtk,nn,istat)</div>
<div class="line">subroutine getVTK_numElems(vtk,ne,istat)</div>
<div class="line">subroutine getVTK_nodesPerElem(vtk,eNoN,istat)</div>
<div class="line">subroutine getVTK_pointCoords(vtk,x,istat)</div>
<div class="line">subroutine getVTK_elemIEN(vtk,ien,istat)</div>
</div><!-- fragment --><p> defined in <code>vtkXMLParser.f90</code>.</p>
<p>The following <code>mesh</code> variables are set </p><div class="fragment"><div class="line">mesh.gnNo - number of nodes</div>
<div class="line">mesh.x - node coordinates</div>
<div class="line">mesh.gN - node IDs </div>
<div class="line">mesh.gnEl - number of elements</div>
<div class="line">mesh.eNoN - number of noders per element</div>
<div class="line">mesh.gIEN - element connectivity (num_nodes_per_elem, num_elems)</div>
</div><!-- fragment --><h2 id="nn_select_ele">nn::select_ele(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set mesh variables for the input element type.</p>
<ul>
<li><code>set_3d_element_props[mesh.eNoN](mesh)</code> - Set element properties based on the number of element nodes</li>
<li><code>get_gip(simulation, mesh)</code> - Set mesh <code>w</code> and <code>xi</code> arrays used for Gauss integration</li>
<li><code>get_gnn(simulation, g, mesh)</code> - Create mesh <code>N</code> and <code>Nx</code> shape function arrays for each Gaus point <code>g</code></li>
<li><code>get_nn_bnds(simulation, mesh)</code> - Create bounds on Gauss integration points and shape functions</li>
</ul>
<h2 id="set_3d_element_props">std::map&lt;int, std::function&lt;void(int, mshType&amp;)&gt;&gt; set_3d_element_props[] </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn_elem_props.h">nn_elem_props.h</a></p>
<p>A map used to set 3D element properties based on the number of element nodes. This replicates the case statement in the Fortran 'SUBROUTINE SELECTELE(lM)' defined in NN.f.</p>
<h2 id="get_gip_mesh">nn::get_gip(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set mesh <code>w</code> and <code>xi</code> arrays used for Gauss integration.</p>
<ul>
<li><code>set_element_gauss_int_data[mesh.eType](mesh)</code></li>
</ul>
<h2 id="get_gnn_mesh">nn:get_gnn(Simulation* simulation, int gaus_pt, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Create mesh <code>N</code> and <code>Nx</code> shape function arrays for a Gauss point <code>gaus_pt</code>.</p>
<ul>
<li>set_element_shape_data[mesh.eType](g, mesh);</li>
</ul>
<h2 id="get_nn_bnds_mesh">nn::get_nn_bnds(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Create bounds on Gauss integration points and shape functions. Replicates Fortran <code>SUBROUTINE GETNNBNDSlMeType, lMeNoN, lMxib, lMNb)</code>.</p>
<h2 id="read_msh_ns_check_ien">read_msh_ns::check_ien(Simulation* simulation, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Check the mesh connectivity and node ordering. It may reorder element connectivity. Replicates the Fortran <code>CHECKIEN</code> subroutine defined in <code>READMSH.f</code>.</p>
<ul>
<li><code>check_element_conn[eType](mesh)</code></li>
</ul>
<h2 id="check_element_conn">std::map&lt;consts::ElementType, std::function&lt;void(mshType&amp;)&gt;&gt; read_msh_ns::check_element_conn </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>A map of function pointers used to check element connecivity.</p>
<ul>
<li>check_tet_conn((<a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; mesh)</li>
<li>check_wedge_conn(mshType&amp; mesh)</li>
</ul>
<h2 id="vtk_xml_read_vtp">vtk_xml::read_vtp(const std::string&amp; file_name, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">vtk_xml.cpp</a></p>
<p>Read a face nodal coordinates and element connectivity from a <code>SimVascular</code> <code>.vtp</code> file. Sets data in <code><a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a></code> face:</p><ul>
<li>face.eNoN - number of noders per element</li>
<li>face.gebc - EBC array (gE + gIEN)</li>
<li>face.gnEl - globel number of elements</li>
<li>face.nEl - number of elements</li>
<li>face.nNo - number of nodes</li>
<li>face.x - node coordinates</li>
</ul>
<p>Replicates Fortran READVTP subroutine defined in VTKXML.f.</p>
<ul>
<li><code>vtk_xml_parser::load_vtp(file_name, face)</code></li>
</ul>
<h2 id="vtk_xml_parser_load_vtp">vtk_xml_parser::load_vtp(const std::string&amp; file_name, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">vtk_xml_parser.cpp</a></p>
<p>Store a surface mesh read in from a VTK <code>.vtp</code> file into a <a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a> object.</p>
<ul>
<li>auto vtk_polydata = reader-&gt;GetOutput()</li>
<li>auto points = vtk_polydata-&gt;GetPoints()</li>
<li>store_nodal_coords(points, face)</li>
<li><code>store_nodal_ids(vtk_polydata, face)</code></li>
<li><code>store_element_conn(vtk_polydata, face)</code></li>
<li><code>store_element_ids(vtk_polydata, face)</code></li>
</ul>
<h2 id="nn_select_eleb">nn::select_eleb(Simulation* simulation, mshType&amp; mesh, faceType&amp; face)) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Set face properties for the input element type.</p>
<ul>
<li><code>get_gip(simulation, face)</code></li>
<li><code>get_gnn(simulation, g, face)</code></li>
</ul>
<h2 id="set_face_element_props">std::map&lt;int, std::function&lt;void(int, mshType&amp;)&gt;&gt; set_face_element_props </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn_elem_props.h">nn_elem_props.h</a></p>
<p>A map type used to set element properties.</p>
<h2 id="get_gip_face">get_gip(Simulation* simulation, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<ul>
<li><code>set_face_gauss_int_data[face.eType](face)</code></li>
</ul>
<h2 id="get_gnn_face">get_gnn(Simulation* simulation, int gaus_pt, faceType&amp; face) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/nn.cpp">nn.cpp</a></p>
<p>Computes shape functions and derivatives at given natural coords.</p>
<ul>
<li><code>set_face_shape_data[face.eType](gaus_pt, face)</code></li>
</ul>
<h2 id="set_projector">set_projector(simulation, avNds) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Associates two faces with each other and sets gN, matches the nodal coordinates for each projection face.</p>
<ul>
<li><code>all_fun::find_face(com_mod.msh, ctmpi, iM, iFa)</code></li>
<li><code>match_faces(com_mod, face1, face2, tol, lPrj)</code></li>
</ul>
<h2 id="find_face">find_face(com_mod.msh, ctmpi, iM, iFa) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/all_fun.cpp">all_fun.cpp</a></p>
<h2 id="match_faces">match_faces(const ComMod&amp; com_mod, const faceType&amp; lFa, const faceType&amp; pFa, const double ptol, utils::stackType&amp; lPrj) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Match isoparameteric faces to each other.</p>
<ul>
<li><code>find_blk(nsd, nBkd, nFlt, xMin, dx, coord)</code></li>
</ul>
<h2 id="find_blk">int find_blk(const int nsd, const int nBkd, const std::vector&lt;bool&gt;&amp; nFlt, const Vector&lt;double&gt;&amp;xMin, const Vector&lt;double&gt;&amp;dx, const Vector&lt;double&gt;&amp; x) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Compute the block ID for the given coordinate.</p>
<h2 id="read_fib_nff">read_fib_nff(Simulation* simulation, mshType&amp; mesh, const std::string&amp; fName, const std::string&amp; kwrd, const int idx) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Read fiber direction from a vtu file.</p>
<ul>
<li><code>vtk_xml_parser::load_fiber_direction_vtu(fName, kwrd, idx, simulation-&gt;com_mod.nsd, mesh)</code></li>
</ul>
<h2 id="load_fiber_direction_vtu">load_fiber_direction_vtu(const std::string&amp; file_name, const std::string&amp; data_name, const int idx, const int nsd, <a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; mesh" </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml_parser.cpp">vtk_xml_parser.cpp</a></p>
<p>Read fiber direction data from a VTK VTU file and copy it into a mesh.</p>
<h2 id="read_vtu_pdata">read_vtu_pdata(const std::string&amp; fName, const std::string&amp; kwrd, const int nsd, const int m, const int idx, mshType&amp; mesh) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/vtk_xml.cpp">vtk_xml.cpp</a></p>
<p>Read prestress data from a vtu file.</p>
<div class="fragment"><div class="line">auto vtk_data = VtkData::create_reader(fName);</div>
<div class="line">int num_elems = vtk_data-&gt;num_elems();</div>
<div class="line">int num_points = vtk_data-&gt;num_points();</div>
</div><!-- fragment --><h2 id="load_var_ini">load_var_ini(Simulation* simulation, ComMod&amp; com_mod) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_msh.cpp">read_msh.cpp</a></p>
<p>Read initial field values (pressure, velocity or displacement).</p>
<h2 id="read_eq">read_eq(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Set equation parameters.</p>
<ul>
<li><code>set_equation_properties(simulation, eq_params, lEq, propL, outPuts, nDOP)</code></li>
</ul>
<h2 id="set_equation_properties">set_equation_properties(Simulation* simulation, <a class="el" href="class_equation_parameters.html" title="The EquationParameters class stores parameters for the &#39;Add_equation&#39; XML element used to specify an ...">EquationParameters</a>&amp; eq_params, <a class="el" href="classeq_type.html" title="Equation type.">eqType</a>&amp; lEq, EquationProps&amp; propL, EquationOutputs&amp; outPuts, EquationNdop&amp; nDOP) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Set equation properties.</p>
<ul>
<li>eq_type = equation_name_to_type.at(eq_type_str)</li>
<li><code>set_equation_props[eq_type](simulation, eq_params, lEq, propL, outPuts, nDOP)</code> - Execute function based on 'eq_type'</li>
</ul>
<h2 id="set_equation_props">std::map&lt;consts::EquationType, std::function&lt;void(Simulation*, <a class="el" href="class_equation_parameters.html" title="The EquationParameters class stores parameters for the &#39;Add_equation&#39; XML element used to specify an ...">EquationParameters</a>&amp;, <a class="el" href="classeq_type.html" title="Equation type.">eqType</a>&amp;, EquationProps&amp;, EquationOutputs&amp;, EquationNdop&amp;)&gt;&gt;) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_equation_props.h">set_equation_props.h</a></p>
<p>A map of lambda functions used to set equation properties.</p>
<h2 id="read_outputs">read_outputs(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq, EquationNdop&amp; nDOP,  EquationOutputs&amp; outPuts) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Set output parameters.</p>
<h2 id="read_bc">read_bc(Simulation* simulation, EquationParameters&amp; eq_params, eqType&amp; lEq, BoundaryConditionParameters&amp; bc_params, bcType&amp; lBc) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Read boundary condition data.</p>
<ul>
<li><code>read_trac_bcff(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)</code></li>
<li><code>read_temporal_values_file(file_name, lBc)</code></li>
<li><code>read_fourier_coeff_values_file(file_name, lBc)</code></li>
<li><code>read_bct(com_mod, lBc.gm, com_mod.msh[iM].fa[iFa], file_name)</code></li>
<li><code>read_temporal_and_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)</code></li>
<li><code>read_spatial_values_file(com_mod, com_mod.msh[iM], com_mod.msh[iM].fa[iFa], file_name, lBc)</code></li>
<li><code>vtk_xml::read_vtp_pdata(cTmp, "Stress", com_mod.nsd, com_mod.nsymd, data_series, face)</code></li>
<li><code>vtk_xml::read_vtp_pdata(cTmp, "Displacement", com_mod.nsd, com_mod.nsd, data_series, face)</code></li>
</ul>
<h2 id="read_trac_bcff">read_trac_bcff(ComMod&amp; com_mod, MBType&amp; lMB, faceType&amp; lFa, const std::string&amp; fName) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Reads pressure/traction data from a vtp file and stores in moving BC data structure.</p>
<div class="fragment"><div class="line">VtkVtpData vtp_data(fName)</div>
<div class="line">int num_points = vtp_data.num_points();</div>
</div><!-- fragment --><h2 id="read_temporal_values_file">read_temporal_values_file(const std::string&amp; file_name, bcType&amp; lBc) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Set boundary condition temporal values read in from a file.</p>
<h2 id="read_fourier_coeff_values_file">read_fourier_coeff_values_file(const std::string&amp; file_name, bcType&amp; lBc) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Set boundary condition Fourier coefficients read in from a file.</p>
<h2 id="read_bct">read_bct(ComMod&amp; com_mod, MBType&amp; lMB, faceType&amp; lFa, const std::string&amp; fName) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Reads general velocity data from bct.vtp.</p>
<div class="fragment"><div class="line">VtkVtpData vtp_data(fName);</div>
<div class="line">int num_points = vtp_data.num_points();</div>
<div class="line">if (num_points == 0) {</div>
</div><!-- fragment --><h2 id="read_spatial_values_file">read_spatial_values_file(const <a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a>&amp; com_mod, const <a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; msh, const <a class="el" href="classface_type.html" title="The face type containing mesh at boundary.">faceType</a>&amp; lFa, const std::string&amp; file_name, <a class="el" href="classbc_type.html" title="Boundary condition data type.">bcType</a>&amp; lBc) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/read_files.cpp">read_files.cpp</a></p>
<p>Read in a file containing spatial values used for a boundary condition.</p>
<h2 id="distribute_data">distribute_data(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to distribute data to MPI processes.</p>
<ul>
<li><code>distribute(simulation)</code></li>
</ul>
<h2 id="distribute">distribute(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Partition and distribute data across processors.</p>
<ul>
<li><code>all_fun::split_jobs(task_id, nMsh, num_proc, wgt, wrk)</code></li>
<li><code>part_msh(simulation, com_mod.msh[iM], gmtl, num_proc, iWgt)</code></li>
<li><code>part_face(simulation, msh, face, tMs[iM].fa[iFa], gmtl)</code></li>
</ul>
<h2 id="bcast">cmType::bcast(const CmMod&amp; cm_mod, ...) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/CmMod.cpp">CmMod.cpp</a></p>
<p>Interfacee to <code>MPI_Bcast()</code>.</p>
<h2 id="split_jobs">split_jobs(int tid, int m, int n, Array&lt;double&gt;&amp; A, Vector&lt;double&gt;&amp; b) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/all_fun.cpp">all_fun.cpp</a></p>
<p>Spliting "m" jobs between "n" workers.</p>
<h2 id="part_msh">part_msh(Simulation* simulation, mshType&amp; lM, Vector&lt;int&gt;&amp; gmtl, int nP, Vector&lt;float&gt;&amp; wgt) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Partition a mesh amongst N processors.</p>
<ul>
<li>Broadcast mesh data. <div class="fragment"><div class="line">cm.bcast(cm_mod, &amp;lM.lShpF);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.lShl);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.lFib);</div>
<div class="line"> </div>
<div class="line">cm.bcast(cm_mod, &amp;eType);</div>
<div class="line"> </div>
<div class="line">cm.bcast(cm_mod, &amp;lM.eNoN);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.nFa);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.nFs);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.nG);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.gnEl);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.gnNo);</div>
<div class="line">cm.bcast(cm_mod, lM.name);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.nFn);</div>
<div class="line">cm.bcast(cm_mod, &amp;lM.scF);</div>
</div><!-- fragment --></li>
<li>Set face properties for the input element type <div class="fragment"><div class="line">nn::select_ele(simulation, lM)`</div>
</div><!-- fragment --></li>
<li>Scattering the lM.gIEN array to all processors. <div class="fragment"><div class="line">MPI_Scatterv(lM.gIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com())</div>
</div><!-- fragment --></li>
<li>Doing partitioning, using ParMetis <div class="fragment"><div class="line">auto edgecut = split_(&amp;nEl, &amp;eNoN, &amp;eNoNb, lM.IEN.data_, &amp;num_proc, lM.eDist.data_,  wgt.data_, part.data_)`</div>
</div><!-- fragment --></li>
<li>Gathering the parts inside master <div class="fragment"><div class="line">MPI_Gatherv(part.data_, nEl, cm_mod::mpint, gPart.data_, sCount.data_, disp.data_, cm_mod::mpint, cm_mod.master, cm.com())</div>
</div><!-- fragment --></li>
<li>Communicating eId, if neccessary <div class="fragment"><div class="line">MPI_Scatterv(tempIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com())</div>
</div><!-- fragment --></li>
<li>Communicating fN, if neccessary <div class="fragment"><div class="line">MPI_Scatterv(tmpFn.data_, sCount.data_, disp.data_, cm_mod::mpreal, lM.fN.data_, nEl*nFn*nsd, cm_mod::mpreal, cm_mod.master, cm.com());</div>
</div><!-- fragment --></li>
<li>scattering the sorted lMIEN to all processors. <div class="fragment"><div class="line">MPI_Scatterv(tempIEN.data_, sCount.data_, disp.data_, cm_mod::mpint, lM.IEN.data_, nEl*eNoN, cm_mod::mpint, cm_mod.master, cm.com());</div>
</div><!-- fragment --></li>
<li>Constructing the initial global to local pointer</li>
</ul>
<h2 id="part_face">part_face(Simulation* simulation, mshType&amp; lM, faceType&amp; lFa, faceType&amp; gFa, Vector&lt;int&gt;&amp; gmtl) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Partition faces across processors.</p>
<ul>
<li>Broadcast the number of nodes and elements of to slaves <div class="fragment"><div class="line">cm.bcast(cm_mod, &amp;gFa.d);</div>
<div class="line">cm.bcast(cm_mod, &amp;gFa.eNoN);</div>
<div class="line">cm.bcast(cm_mod, &amp;gFa.iM);</div>
<div class="line">cm.bcast(cm_mod, &amp;gFa.nEl);</div>
<div class="line">cm.bcast(cm_mod, &amp;gFa.gnEl);</div>
<div class="line">cm.bcast(cm_mod, &amp;gFa.nNo);</div>
</div><!-- fragment --></li>
<li><code>nn::select_eleb(simulation, lM, gFa)</code> - Set face properties for the input element type.</li>
</ul>
<h2 id="dist_eq">dist_eq(<a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a>&amp; com_mod, const <a class="el" href="class_cm_mod.html" title="The CmMod class duplicates the data structures in the Fortran CMMOD module defined in COMU....">CmMod</a>&amp; cm_mod, const <a class="el" href="classcm_type.html" title="The cmType class stores data and defines methods used for mpi communication.">cmType</a>&amp; cm, const std::vector&lt;mshType&gt;&amp; tMs, const <a class="el" href="class_vector.html">Vector&lt;int&gt;</a>&amp; gmtl, <a class="el" href="class_cep_mod.html">CepMod</a>&amp; cep_mod, <a class="el" href="classeq_type.html" title="Equation type.">eqType</a>&amp; lEq) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Distribute equation data to processors.</p>
<ul>
<li>Distribute equation parameters <div class="fragment"><div class="line">cm.bcast(cm_mod, &amp;lEq.nOutput);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.coupled);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.maxItr);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.minItr);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.roInf);</div>
<div class="line">cm.bcast_enum(cm_mod, &amp;lEq.phys);</div>
<div class="line">...</div>
</div><!-- fragment --></li>
<li>Distribute linear solver settings <div class="fragment"><div class="line">cm.bcast(cm_mod, &amp;lEq.FSILS.foC);</div>
<div class="line">cm.bcast_enum(cm_mod, &amp;lEq.FSILS.LS_type);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.FSILS.RI.relTol);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.FSILS.GM.relTol);</div>
<div class="line">cm.bcast(cm_mod, &amp;lEq.FSILS.CG.relTol);</div>
<div class="line">...</div>
</div><!-- fragment --></li>
<li>Distribute domain properties</li>
<li><code>dist_mat_consts(com_mod, cm_mod, cm, dmn.stM)</code></li>
</ul>
<h2 id="dist_mat_consts">dist_mat_consts(const ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, stModelType&amp; lStM) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Distribute material properties to all processors.</p>
<h2 id="dist_bc">dist_bc(ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, bcType&amp; lBc, const std::vector&lt;mshType&gt;&amp; tMs, const Vector&lt;int&gt;&amp; gmtl) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Distribute boundary condition data to all processors.</p>
<h2 id="dist_visc_model">dist_visc_model(const ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, viscModelType&amp; lVis) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Distribute viscosity model to processors.</p>
<h2 id="dist_bf">dist_bf(ComMod&amp; com_mod, const CmMod&amp; cm_mod, const cmType&amp; cm, bfType&amp; lBf) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/distribute.cpp">distribute.cpp</a></p>
<p>Distribute boundary fource to processors.</p>
<h2 id="initialize_solution">initialize_solution(Simulation* simulation, double* timep) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<p>C++ / Fortran interface function used to initialize the solution.</p>
<ul>
<li><code>initialize(simulation, timeP)</code></li>
</ul>
<h2 id="initialize">initialize(Simulation* simulation, Vector&lt;double&gt;&amp; timeP) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/initialize.cpp">initialize.cpp</a></p>
<p>Initialize or finalize svFSI variables/structures.</p>
<p>Sets the following for each com_mod.eq[]. </p><div class="fragment"><div class="line">eq.am</div>
<div class="line">eq.dof</div>
<div class="line">eq.pNorm</div>
<div class="line">eq.af</div>
<div class="line">eq.beta</div>
<div class="line">eq.gam</div>
<div class="line">eq.s</div>
<div class="line">eq.e</div>
<div class="line"> </div>
<div class="line">com_mod.Ao.resize(tDof,tnNo);</div>
<div class="line">com_mod.An.resize(tDof,tnNo);</div>
<div class="line">com_mod.Yo.resize(tDof,tnNo);</div>
<div class="line">com_mod.Yn.resize(tDof,tnNo);</div>
<div class="line">com_mod.Do.resize(tDof,tnNo);</div>
<div class="line">com_mod.Dn.resize(tDof,tnNo);</div>
<div class="line">com_mod.Bf.resize(nsd,tnNo);</div>
<div class="line"> </div>
<div class="line">com_mod.An = com_mod.Ao;</div>
<div class="line">com_mod.Yn = com_mod.Yo;</div>
<div class="line">com_mod.Dn = com_mod.Do;</div>
</div><!-- fragment --><ul>
<li><code>mat_fun::ten_init(nsd)</code></li>
<li><code>lhsa_ns::lhsa(simulation, nnz)</code> - Constructing stiffness matrix</li>
<li><code>fsi_linear_solver::fsils_lhs_create(com_mod.lhs, communicator, com_mod.gtnNo, com_mod.tnNo, nnz, com_mod.ltg, com_mod.rowPtr, com_mod.colPtr, nFacesLS)</code></li>
<li><code>cep_ion::cep_init(simulation)</code></li>
<li><code>fs::init_fs_msh(com_mod, mesh)</code></li>
<li><code>baf_ini_ns::baf_ini(simulation)</code></li>
<li><code>set_bc::set_bc_dir(com_mod, com_mod.Ao, com_mod.Yo, com_mod.Do)</code></li>
<li><code>txt_ns::txt(simulation, true)</code></li>
</ul>
<h2 id="lsh">void lhsa(Simulation* simulation, int&amp; nnz) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp">lhsa.cpp</a></p>
<p>Create data structure and assembling LHS sparse matrix.</p>
<p>Modifies: </p><div class="fragment"><div class="line">com_mod.idMap</div>
<div class="line">com_mod.colPtr</div>
<div class="line">com_mod.rowPtr</div>
</div><!-- fragment --><h2 id="fsils_commu_create">void fsils_commu_create(FSILS_commuType&amp; commu, cm_mod::MpiCommWorldType commi) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/commu.cpp">commu.cpp</a></p>
<p>Modifies: </p><div class="fragment"><div class="line">commu.task</div>
<div class="line">commu.nTasks</div>
<div class="line"> </div>
<div class="line">commu.foC = true;</div>
<div class="line">commu.comm = commi;</div>
<div class="line">commu.nTasks = 1;</div>
<div class="line">commu.task   = 0;</div>
<div class="line">commu.master = 0;</div>
</div><!-- fragment --><h2 id="fsils_lhs_create">void fsils_lhs_create(FSILS_lhsType&amp; lhs, FSILS_commuType&amp; commu, int gnNo, int nNo, int nnz, Vector&lt;int&gt;&amp; gNodes, Vector&lt;int&gt; &amp;rowPtr, Vector&lt;int&gt;&amp; colPtr, int nFaces) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/lhs.cpp">lhs.cpp</a></p>
<p>Create data structure and assembling LHS sparse matrix.</p>
<p>Modifies: </p><div class="fragment"><div class="line">lhs.foC </div>
<div class="line">lhs.gnNo </div>
<div class="line">lhs.nNo </div>
<div class="line">lhs.nnz </div>
<div class="line">lhs.commu </div>
<div class="line">lhs.nFaces </div>
<div class="line">lhs.mynNo </div>
<div class="line"> </div>
<div class="line">lhs.colPtr</div>
<div class="line">lhs.rowPtr</div>
<div class="line">lhs.diagPtr</div>
<div class="line">lhs.map</div>
<div class="line">lhs.face</div>
</div><!-- fragment --><h2 id="cep_init">void cep_init(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/cep_ion.cpp">cep_ion.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">cep_mod.Xion</div>
</div><!-- fragment --><ul>
<li><code>cep_init_l(cep_mod, eq.dmn[iDmn].cep, nX, nG, Xl, Xgl)</code></li>
<li><code>all_fun::commu(com_mod, sA)</code></li>
<li><code>all_fun::commu(com_mod, sF)</code></li>
</ul>
<h2 id="init_fs_msh">void init_fs_msh(const ComMod&amp; com_mod, mshType&amp; lM) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fs.cpp">fs.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">lM.fs.resize(lM.nFs)</div>
<div class="line">lM.fs[0].lShpF = lM.lShpF;</div>
<div class="line">lM.fs[0].eType = lM.eType;</div>
<div class="line">lM.fs[0].eNoN  = lM.eNoN;</div>
<div class="line">lM.fs[0].nG    = lM.nG;</div>
</div><!-- fragment --><ul>
<li><code>nn::get_gn_nxx(insd, ind2, lM.fs[0].eType, lM.fs[0].eNoN, g, lM.fs[0].xi, lM.fs[0].Nxx)</code></li>
<li><code>set_thood_fs(lM.fs[1], lM.fs[0].eType)</code></li>
<li><code>alloc_fs(lM.fs[1], nsd, insd)</code></li>
</ul>
<h2 id="baf_ini">void baf_ini(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp">baf_ini.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">com_mod.cplBC.fa</div>
<div class="line">com_mod.cplBC.xn</div>
<div class="line"> </div>
<div class="line">com_mod.cplBC.fa[i].RCR.Rp = bc.RCR.Rp;</div>
<div class="line">com_mod.cplBC.fa[i].RCR.C  = bc.RCR.C;</div>
<div class="line">com_mod.cplBC.fa[i].RCR.Rd = bc.RCR.Rd;</div>
<div class="line">com_mod.cplBC.fa[i].RCR.Pd = bc.RCR.Pd;</div>
<div class="line">com_mod.cplBC.fa[i].RCR.Xo = bc.RCR.Xo;</div>
</div><!-- fragment --><ul>
<li><code>face_ini(simulation, msh, face)</code> - Compute face normals and area</li>
<li><code>shl_ini(com_mod, cm_mod, com_mod.msh[iM])</code></li>
<li><code>bc_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa])</code> - Initialize face BC profile</li>
<li><code>shl_bc_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], com_mod.msh[iM])</code></li>
<li><code>set_bc::rcr_init(com_mod, cm_mod)</code></li>
<li><code>set_bc::genBC_Integ_X(com_mod, cm_mod, "I")</code></li>
<li><code>set_bc::calc_der_cpl_bc(com_mod, cm_mod)</code></li>
<li><code>fsi_ls_ini(com_mod, cm_mod, bc, com_mod.msh[iM].fa[iFa], lsPtr)</code></li>
<li><code>fsils_bc_create(com_mod.lhs, lsPtr, i, nsd, BcType::BC_TYPE_Dir, gNodes)</code></li>
</ul>
<h2 id="fsi_ls_ini">void fsi_ls_ini(ComMod&amp; com_mod, const CmMod&amp; cm_mod, bcType&amp; lBc, const faceType&amp; lFa, int&amp; lsPtr) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/baf_ini.cpp">baf_ini.cpp</a></p>
<p>Modifies </p><div class="fragment"></div><!-- fragment --><ul>
<li><code>fsils_bc_create(com_mod.lhs, lsPtr, lFa.nNo, nsd, BcType::BC_TYPE_Dir, gNodes, sVl)</code></li>
</ul>
<h2 id="fsils_bc_create">void fsils_bc_create(FSILS_lhsType&amp; lhs, int faIn, int nNo, int dof, BcType BC_type, const <a class="el" href="class_vector.html">Vector&lt;int&gt;</a>&amp; gNodes, Array&lt;double&gt; Val) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSILS_cinterface/bc.cpp">bc.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">lhs.face[faIn]</div>
</div><!-- fragment --><ul>
<li><code>MPI_Allreduce(&amp;a, &amp;Ac, 1, cm_mod::mpint, MPI_SUM, lhs.commu.comm)</code></li>
<li><code>fsils_commuv(lhs, dof, v)</code></li>
</ul>
<h2 id="set_bc_dir">void set_bc_dir(ComMod&amp; com_mod, Array&lt;double&gt;&amp; lA, Array&lt;double&gt;&amp; lY, Array&lt;double&gt;&amp; lD) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp">set_bc.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">com_mod.Ad</div>
<div class="line">lA(tDof, tnNo)</div>
<div class="line">lY(tDof, tnNo)</div>
<div class="line">lD(tDof, tnNo)</div>
</div><!-- fragment --><ul>
<li><code>set_bc::set_bc_dir_l(com_mod, bc, com_mod.msh[iM].fa[iFa], tmpA, tmpY, lDof)</code></li>
</ul>
<h2 id="set_bc_dir_l">void set_bc_dir_l(ComMod&amp; com_mod, const bcType&amp; lBc, const faceType&amp; lFa, Array&lt;double&gt;&amp; lA, Array&lt;double&gt;&amp; lY, int lDof) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/set_bc.cpp">set_bc.cpp</a></p>
<p>Modifies </p><div class="fragment"></div><!-- fragment --><ul>
<li><code>igbc(com_mod, lBc.gm, lY, lA)</code> - calculating values by the inverse of general BC</li>
<li><code>ifft(com_mod, lBc.gt, dirY_v, dirA_v)</code></li>
</ul>
<h2 id="iterate_solution">void iterate_solution(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/simulation_wrap.cpp">simulation_wrap.cpp</a></p>
<ul>
<li><code>read_msh_ns::calc_mesh_props(com_mod, cm_mod, com_mod.nMsh, com_mod.msh)</code></li>
<li><code>pic::picp(simulation)</code></li>
<li><code>set_bc::set_bc_dir(com_mod, An, Yn, Dn)</code></li>
<li>Inner loop for iteration<ul>
<li><code>set_bc::set_bc_cpl(com_mod, cm_mod)</code></li>
<li><code>set_bc::set_bc_dir(com_mod, An, Yn, Dn)</code></li>
<li><code>pic::pici(simulation, Ag, Yg, Dg)</code></li>
<li><code>ls_ns::ls_alloc(com_mod, eq)</code></li>
<li><code>bf::set_bf(com_mod, Dg)</code></li>
<li><code>eq_assem::global_eq_assem(com_mod, com_mod.msh[iM], Ag, Yg, Dg)</code> - For each mesh</li>
<li><code>set_bc::set_bc_neu(com_mod, cm_mod, Yg, Dg)</code></li>
<li><code>set_bc::set_bc_cmm(com_mod, cm_mod, Ag, Dg)</code></li>
<li><code>set_bc::set_bc_dir_w(com_mod, Yg, Dg)</code> - Apply weakly applied Dirichlet BCs</li>
<li><code>contact::contact_forces(com_mod, cm_mod, Dg)</code></li>
<li><code>all_fun::commu(com_mod, com_mod.R)</code> - Synchronize residual across processes</li>
<li><code>ustruct::ustruct_r(com_mod, Yg)</code></li>
<li><code>fs::thood_val_rc(com_mod)</code></li>
<li><code>set_bc::set_bc_undef_neu(com_mod)</code></li>
<li><code>ls_ns::ls_solve(com_mod, eq, incL, res)</code></li>
<li><code>pic::picc(simulation)</code></li>
</ul>
</li>
</ul>
<h2 id="picp">void picp(Simulation* simulation) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/pic.cpp">pic.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">pS0 </div>
<div class="line">Ad </div>
<div class="line">Ao </div>
<div class="line">Yo </div>
<div class="line">Do </div>
<div class="line">An </div>
<div class="line">Yn </div>
<div class="line">Dn </div>
</div><!-- fragment --><ul>
<li><code>cep_ion::cep_integ(simulation, iEq, e, Do)</code></li>
</ul>
<h2 id="ls_alloc">void ls_alloc(ComMod&amp; com_mod, eqType&amp; lEq) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/ls.cpp">ls.cpp</a></p>
<p>Allocate <code>com_mod.R</code> and <code>com_mod.Val</code> arrays.</p>
<p>Modifies </p><div class="fragment"><div class="line">com_mod.R - Residual vector</div>
<div class="line">com_mod.Val - LHS matrix</div>
</div><!-- fragment --><ul>
<li>if using trilinos<ul>
<li><code>trilinos_lhs_create_(gtnNo, lhs.mynNo, tnNo, lhs.nnz, tls.ltg.data(), com_mod.ltg.data(), com_mod.rowPtr.data(), com_mod.colPtr.data(), dof)</code></li>
</ul>
</li>
</ul>
<h2 id="set_bf">void set_bf(ComMod&amp; com_mod, Array&lt;double&gt;&amp; Dg) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">bf.cpp</a></p>
<ul>
<li><code>set_bf_l(com_mod, eq.bf[iBf], com_mod.msh[iM], Dg)</code></li>
</ul>
<h2 id="set_bf_l">void set_bf_l(ComMod&amp; com_mod, bfType&amp; lBf, mshType&amp; lM, Array&lt;double&gt;&amp; Dg) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">bf.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">com_mod.Bf</div>
</div><!-- fragment --><ul>
<li><code>ifft(com_mod, lBf.bt, f, rtmp)</code> - If BodyForceType::bfType_ustd</li>
<li><code>igbc(com_mod, lBf.bm, bfl, xl)</code> - If BodyForceType::bfType_gen</li>
<li><code>bf_construct(com_mod, lM, e, eNoN, idof, xl, dl, bfl, ptr)</code></li>
</ul>
<h2 id="bf_construct">void bf_construct(<a class="el" href="class_com_mod.html" title="The ComMod class duplicates the data structures in the Fortran COMMOD module defined in MOD....">ComMod</a>&amp; com_mod, const <a class="el" href="classmsh_type.html" title="This is the container for a mesh or NURBS patch, those specific to NURBS are noted.">mshType</a>&amp; lM, const int e, const int eNoN, const int idof, Array&lt;double&gt;&amp; xl, const Array&lt;double&gt;&amp; dl, const Array&lt;double&gt;&amp; bfl, const <a class="el" href="class_vector.html">Vector&lt;int&gt;</a>&amp; ptr) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/bf.cpp">bf.cpp</a></p>
<ul>
<li><code>cmm::bcmmi(com_mod, eNoN, idof, w, N, Nx, xl, bfl, lR)</code></li>
<li><code>trilinos_doassem_(const_cast&lt;int&amp;&gt;(eNoN), ptr.data(), lK.data(), lR.data())</code> - If using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
<li><code>lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)</code> - If not using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
</ul>
<h2 id="global_eq_assem">void global_eq_assem(ComMod&amp; com_mod, const mshType&amp; lM, const Array&lt;double&gt;&amp; Ag, const Array&lt;double&gt;&amp; Yg, const Array&lt;double&gt;&amp; Dg) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/eq_assem.cpp">eq_assem.cpp</a></p>
<ul>
<li>`fluid::construct_fluid(com_mod, lM, Ag, Yg) - If EquationType::phys_fluid</li>
</ul>
<h2 id="construct_fluid">void construct_fluid(ComMod&amp; com_mod, const mshType&amp; lM, const Array&lt;double&gt;&amp; Ag, const Array&lt;double&gt;&amp; Yg) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/fluid.cpp">fluid.cpp</a></p>
<p>This is for solving fluid transport equation solving Navier-Stokes equations. Dirichlet boundary conditions are either treated strongly or weakly.</p>
<ul>
<li><code>fs::get_thood_fs(com_mod, fs, lM, vmsStab, 1)</code></li>
<li><code>nn::gnn(fs[1].eNoN, nsd, nsd, Nx, xql, Nqx, Jac, ksix)</code></li>
<li><code>nn::gn_nxx(l, fs[0].eNoN, nsd, nsd, Nx, Nxx, xwl, Nwx, Nwxx)</code></li>
<li><code>fluid_3d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK)</code> - If nsd=3</li>
<li><code>fluid_2d_m(com_mod, vmsStab, fs[0].eNoN, fs[1].eNoN, w, ksix, N0, N1, Nwx, Nqx, Nwxx, al, yl, bfl, lR, lK)</code> - If nsd=2</li>
<li><code>trilinos_doassem_(const_cast&lt;int&amp;&gt;(eNoN), ptr.data(), lK.data(), lR.data())</code> - If using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
<li><code>lhsa_ns::do_assem(com_mod, eNoN, ptr, lK, lR)</code> - If not using <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></li>
</ul>
<h2 id="do_assem">void do_assem(ComMod&amp; com_mod, const int d, const Vector&lt;int&gt;&amp; eqN, const Array3&lt;double&gt;&amp; lK, const Array&lt;double&gt;&amp; lR) </h2>
<p><a href="https://github.com/ktbolt/svFSI/blob/Implement-svFSI-using-cpp_19/Code/Source/svFSI_cinterface/lhsa.cpp">lhsa.cpp</a></p>
<p>Modifies </p><div class="fragment"><div class="line">com_mod.R</div>
<div class="line">com_mod.Val</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
